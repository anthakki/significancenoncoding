/************************************************************           
 * Noncoding Significance Analysis of Hg19					*
 * 															*   
 * Author:		Felix Dietlein								*   
 *															*   
 * Copyright:	(C) 2021 									*   
 *															*   
 * License:		BSD-3-Clause open source license			*   
 *															*   
 * Summary: This script summarizes the p-values from the 	*
 * 			10kb and 100kb intervals to a combined p-value.	*
 * 			Subsequently, it performes an expression-based	*
 * 			weighted multiple hypotheses correction and 	*
 * 			annotates significantly mutated regions 		*
 * 			(FDR<0.1) by their closest gene.				*
 * 															*   
 ************************************************************/

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileWriter;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Hashtable;

import org.apache.commons.math3.distribution.ChiSquaredDistribution;

public class Combine_PValues_FDR {
	static String separator="/";	//separator for file names (changes between Windows and Unix)
	static String folder_significance="";	// folder of the  significance file generated by the previous steps method
	static String folder_annotation="";		//Hg19 annotation folder (e.g. epigenomic data). Will be downloaded if it cannot be found
	static String folder_auxiliary="";	//folder in which the intermediate files are written. Result files will be written to this method 
	
	static String file_genes=folder_annotation+"GeneTrackIGV_New"+separator+"Chr"; //annotation of the positions of genes (to identify the closest gene)
	static String file_coverage=folder_annotation+"CoverageFiles"+separator+"Coverage_"; //annotation of coverage (to exclude low coverage regions)
	static String file_symbols=folder_annotation+"Hg19"+separator+"ApprovedSymbols.txt";//annotation of gene names 
	static String file_expression=folder_annotation+"Expression"+separator;//annotation of cancer specific expression 
	static String file_transform_mir=folder_annotation+"Hg19"+separator+"TransformMIR.txt"; //annotation of MIR gene names
	
	static int[] chr_length={ //chromosome length in Hg19
			249250621,
			243199373,
			198022430,
			191154276,
			180915260,
			171115067,
			159138663,
			146364022,
			141213431,
			135534747,
			135006516,
			133851895,
			115169878,
			107349540,
			102531392,
			90354753,
			81195210,
			78077248,
			59128983,
			63025520,
			48129895,
			51304566,
			155270560,
			59373566
		};
	static String[] chr={"1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","17","18","19","20","21","22","X","Y"};
	static int max_dist=1000000; //maximum distance between a significant region and its closest gene
	static ArrayList<String> gene_names=new ArrayList<String>(); //gene names for annotating the closest gene
	static Hashtable<String, Integer> search_table2=new Hashtable<String, Integer>();//table to look up the position of genes by their names
	static ArrayList<int[]> gene_borders=new ArrayList<int[]>();//gene borders for annotating of closest gene
	static ArrayList<String> symbol=new ArrayList<String>();//official symbol of genes
	static Hashtable<String,Integer> table=new Hashtable<String,Integer>();//table to look up the official symbol name of genes 
	static int[] shift={0,2500,5000,7500};//offsets of 10kb intervals for which the significance should be combined
	static int[] shift_100={0,25000,50000,75000};//offsets of 100kb intervals for which the significance should be combined
	
	//look up the TCGA identifier by cancer type names to associate them with their cancer type specific position
	public static String[] get_expression_entities(String entity){
		
		if(entity.equals("Biliary")){
			return new String[]{"CHOL"};
		}
		if(entity.equals("Bladder")){
			return new String[]{"BLCA"};
		}
		if(entity.equals("Brain")){
			return new String[]{"GBM","GBMLGG","LGG"};
		}
		if(entity.equals("Breast")){
			return new String[]{"BRCA"};
		}
		if(entity.equals("Cervix")){
			return new String[]{"CESC"};
		}
		if(entity.equals("Colorectal")){
			return new String[]{"COAD","COADREAD","READ"};
		}
		if(entity.equals("Endocrine")){
			return new String[]{};//"Endocrine"
		}
		if(entity.equals("Endometrium")){
			return new String[]{"UCEC"};
		}
		if(entity.equals("Esophagus")){
			return new String[]{"ESCA"};
		}
		if(entity.equals("Gastric")){
			return new String[]{"STAD"};
		}
		if(entity.equals("HeadNeck")){
			return new String[]{"HNSC"};
		}
		if(entity.equals("Kidney")){
			return new String[]{"KICH","KIPAN","KIRC","KIRP"};
		}
		if(entity.equals("Leukemia")){
			return new String[]{"LAML"};
		}
		if(entity.equals("Liver")){
			return new String[]{"LIHC"};
		}
		if(entity.equals("Lung")){
			return new String[]{"LUAD","LUSC"};
		}
		if(entity.equals("Lymphoma")){
			return new String[]{"DLBC"};
		}
		if(entity.equals("Myeloid")){
			return new String[]{};//"Myeloid"
		}
		if(entity.equals("Ovary")){
			return new String[]{"OV"};
		}
		if(entity.equals("Pancreas")){
			return new String[]{"PAAD"};
		}
		if(entity.equals("Pleura")){
			return new String[]{"MESO"};
		}
		if(entity.equals("Prostate")){
			return new String[]{"PRAD"};
		}
		if(entity.equals("Sarcoma")){
			return new String[]{"SARC"};
		}
		if(entity.equals("Skin")){
			return new String[]{"SKCM"};
		}
		if(entity.equals("Thyroid")){
			return new String[]{"THCA"};
		}
		
		return new String[]{};
	}
	
	//intitiate paths and global variables based on the parameters parsed to the script from outside
	public static void initiate(String folder_annotationX, String folder_significanceX, String folder_auxiliaryX){

		folder_annotation=folder_annotationX;
		folder_significance=folder_significanceX;
		folder_auxiliary=folder_auxiliaryX;
		
		file_genes=folder_annotation+"GeneTrackIGV_New"+separator+"Chr";
		file_coverage=folder_annotation+"CoverageFiles"+separator+"Coverage_";
		file_symbols=folder_annotation+"Hg19"+separator+"ApprovedSymbols.txt";
		file_expression=folder_annotation+"Expression"+separator;
		file_transform_mir=folder_annotation+"Hg19"+separator+"TransformMIR.txt";
		
		gene_names=new ArrayList<String>();
		search_table2=new Hashtable<String, Integer>();
		gene_borders=new ArrayList<int[]>();
		symbol=new ArrayList<String>();
		table=new Hashtable<String,Integer>();
		
	}
	
	//main function called from outside to execute the script. the script first initializes the global variables and file paths
	//next, it combines the signifcance values for 10kb and 100kb intervals and performs an expression-based weighted multiple hypothesis correction
	//to arrive at q-values for 10kb and 100kb intervalls. finally, it derives a combined genome-wide signal of significance by combining the FDR from 10kb and 100kb intervals
	//that annotates a unique significance value to each position in the human genome
	//based on this signal, it identifies significantly mutated regions (FDR<0.1) and annotates the closest gene
	public static void execute(String entity, String folder_annotationX,  String folder_significanceX, String folder_auxiliaryX) throws java.io.IOException {
		boolean isWindows = System.getProperty("os.name").toLowerCase().startsWith("windows");
		if(isWindows){
			separator="\\";
		}
		else{
			separator="/";
		}
		
		initiate(folder_annotationX, folder_significanceX, folder_auxiliaryX);
		
		
		String[] entities=get_expression_entities(entity);
		
		gene_names=new ArrayList<String>();
		search_table2=new Hashtable<String, Integer>();
		gene_borders=new ArrayList<int[]>();
		symbol=new ArrayList<String>();
		table=new Hashtable<String,Integer>();
		
		{
			load_genes();
			read_symbol_list();
			
			
			boolean expression_available=true;
			if(entities.length==0){
				expression_available=false;
			}
			
			double[] max95=null;
			if(expression_available){
				max95=read_expression(entities);
			}
			
			double[][][] coverage=read_coverage(new int[]{0,2500,5000,7500});
			boolean[][][] coverage_valid=read_coverage_valid(new int[]{0,25000,50000,75000});
			
			
			double[][][][] sign_fdr=read_sign_fdr(entity,max95,expression_available,coverage);
			double[][][][] sign_fdr_100=read_sign_fdr_100(entity,max95,expression_available,coverage_valid);
			
			double[][][] fdr_weight=sign_fdr[2];
			double[][][] fdr_weight_100=sign_fdr_100[2];
			
			double[][] fdr_weight_combine=fdr_combine(fdr_weight, fdr_weight_100, new int[]{0,2500,5000,7500}, new int[]{0,25000,50000,75000});
	
			{
				int shift=0;
				int width=2500;
				ArrayList<Integer>[][] index_gene=index_gene(shift, width);
				String out_fn=folder_auxiliary+"FDR_Weighted_Combined_"+entity+".txt"+SignificanceNoncoding.out_suffix;
				java.io.FileOutputStream out=new java.io.FileOutputStream(out_fn);
				BufferedWriter output= new BufferedWriter(new java.io.OutputStreamWriter(ZipFilter.filterOutputStream(out, out_fn)));
				for (int i=0;i<fdr_weight_combine.length;i++){
					for (int j=0;j<fdr_weight_combine[i].length;j++){
						if(fdr_weight_combine[i][j]<0.1){
							String[] sss=look_up_array(i, j, index_gene, max_dist, width, max95, search_table2,expression_available);
							String label="";
							if(expression_available){
								double max95_max=0;
								String label_max="";
								ArrayList<String> genes=new ArrayList<String>();
								if(sss.length>0){
									for (int k=0;k<sss.length;k++){
										Integer ii=search_table2.get(sss[k].toUpperCase());
										if(ii!=null){
											if(max95[ii]>max95_max){
												max95_max=max95[ii];
												label_max=sss[k];
											}
											if(max95[ii]>0&&!Double.isNaN(max95[ii])){
												genes.add(sss[k]);
											}
										}
									}
								}
								label=label_max+"(*)";
								if(genes.size()>0){
									for (int k=0;k<genes.size();k++){
										if(!genes.get(k).equals(label_max)){
											label=label+", "+genes.get(k);
										}
									}
								}
							}
							else{
								if(sss.length>0){
									for (int k=0;k<sss.length;k++){
										if(k==0){
											label=sss[k];
										}
										else{
											label=label+", "+sss[k];
										}
									}
								}
							}
							
							
							output.write(chr[i]+"	"+(j*2500)+"	"+fdr_weight_combine[i][j]+"	"+label);
						}
						else{
							output.write(chr[i]+"	"+(j*2500)+"	"+fdr_weight_combine[i][j]);
						}
						output.newLine();
						
					}
				}
				output.close();
			}
			
			
		}
	}
	
	//read coverage files for 10kb intervals with multiple interval offsets
	public static double[][][] read_coverage(int[] shift_mut) throws java.io.IOException {
		double[][][] coverage=new double[shift_mut.length][][];
		for (int i=0;i<shift_mut.length;i++){
			coverage[i]=read_coverage(shift_mut[i]);
		}
		return coverage;
	}
	
	//read coverage files for 100kb intervals with multiple interval offsets
	public static boolean[][][] read_coverage_valid(int[] shift_mut) throws java.io.IOException {
		boolean[][][] coverage_valid=new boolean[shift_mut.length][][];
		for (int i=0;i<shift_mut.length;i++){
			coverage_valid[i]=read_coverage_valid(shift_mut[i]);
		}
		return coverage_valid;
	}
	
	//read coverage file for 100kb intervals for a single offset
	public static boolean[][] read_coverage_valid(int shift_mut) throws java.io.IOException {
		double[][] coverage=read_coverage(shift_mut);
		
		int[][] coverage_valid_n=new int[chr.length][];
		for (int i=0;i<chr.length;i++){
			coverage_valid_n[i]=new int[1+(chr_length[i]-shift_mut)/100000];
			for (int j=0;j<coverage_valid_n[i].length;j++){
				for (int jj=0;jj<10;jj++){
					if(j*10+jj<coverage[i].length&&low(chr[i])<=coverage[i][j*10+jj]&&coverage[i][j*10+jj]<high(chr[i])){
						
					}
					else{
						coverage_valid_n[i][j]++;
					}
				}
			}
		}
		
		boolean[][] coverage_valid=new boolean[chr.length][];
		for (int i=0;i<coverage_valid.length;i++){
			coverage_valid[i]=new boolean[1+(chr_length[i]-shift_mut)/100000];
			for (int j=0;j<coverage_valid[i].length;j++){
				if(coverage_valid_n[i][j]<=1){
					coverage_valid[i][j]=true;
				}
				else{
					coverage_valid[i][j]=false;
					
				}
			}
		}
		
		return coverage_valid;
	}
	
	//read coverage file for 10kb intervals for a single offset
	public static double[][] read_coverage(int shift_mut) throws java.io.IOException {
		double[][] coverage=new double[chr.length][];
		{
			double[][] coverage_n=new double[chr.length][];
			for (int i=0;i<chr.length;i++){
				coverage[i]=new double[1+(chr_length[i]-shift_mut)/10000];
				coverage_n[i]=new double[1+(chr_length[i]-shift_mut)/10000];
			}
			
			java.io.InputStream in=ZipOverlay.fileInputStream(file_coverage+shift_mut+".txt");//TODO: adapt file OK
			BufferedReader input= new BufferedReader(new InputStreamReader(ZipFilter.filterInputStream(in)));
			
			String s="";
			while((s=input.readLine())!=null){
				String[] t=s.split("	");
				if(index(t[0],chr)==-1){
					continue;
				}
				for (int k=(Integer.parseInt(t[1])-shift_mut)/10000;k<Math.min(chr_length[index(t[0],chr)]-shift_mut, Integer.parseInt(t[1])-shift_mut+10000)/10000;k++){
					if(k>=0){
						coverage[index(t[0],chr)][k]+=Double.parseDouble(t[2]);	//TODO: shift  OK
						coverage_n[index(t[0],chr)][k]++;
					}
				
				}
			}
			input.close();
			
			for (int i=0;i<coverage.length;i++){
				for (int j=0;j<coverage[i].length;j++){
					if(coverage_n[i][j]>0){
						coverage[i][j]/=coverage_n[i][j];
					}
					else{
						coverage[i][j]=Double.NaN;
					}
				}
			}
		}
		return coverage;
	}
	
	
	
	//combine FDRs of 10kb and 100kb to a genome-wide signal of significance which annotates a single significance value to each position in the genome 
	public static double[][] fdr_combine(double[][][] fdr_weight, double[][][] fdr_weight_100, int[] shift, int[] shift_100){
		
		ArrayList<Sign2> significance=new ArrayList<Sign2>();
		for (int k=0;k<shift.length;k++){
			for (int i=0;i<chr.length;i++){
				for (int j=0;j<(chr_length[i]-shift[k])/10000;j++){
					significance.add(new Sign2(i,j*10000+shift[k],(j+1)*10000+shift[k],fdr_weight[i][(j*10000+shift[k])/2500][k]));
					
				}
			}
		}
		for (int k=0;k<shift_100.length;k++){
			for (int i=0;i<chr.length;i++){
				for (int j=0;j<(chr_length[i]-shift_100[k])/100000;j++){
					significance.add(new Sign2(i,j*100000+shift_100[k],(j+1)*100000+shift_100[k],fdr_weight_100[i][(j*100000+shift_100[k])/25000][k]));
					
				}
			}
		}
		
		Comparator<Sign2> comp=(Sign2 s1, Sign2 s2)->{
			if(s1.q<0.001&&s2.q<0.001&&(s1.end-s1.start)!=(s2.end-s2.start)){
				return new Integer(s1.end-s1.start).compareTo(s2.end-s2.start);
			}
			return new Double(s1.q).compareTo(s2.q);
		};
		
		
		Collections.shuffle(significance);
		Collections.sort(significance,comp);
		
		int[][] given=new int[chr.length][];
		for (int i=0;i<chr.length;i++){
			given[i]=new int[1+chr_length[i]/2500];
			for (int j=0;j<given[i].length;j++){
				given[i][j]=-1;
			}
		}
		
		double[][] fdr2=new double[chr.length][];
		for (int i=0;i<fdr2.length;i++){
			fdr2[i]=new double[1+chr_length[i]/2500];
			for (int j=0;j<fdr2[i].length;j++){
				fdr2[i][j]=1;
			}
		}
		
		for (int i=0;i<significance.size();i++){
			boolean redundant=false;
			for (int j=significance.get(i).start/2500;j<significance.get(i).end/2500;j++){
				if(j<given[significance.get(i).chr_index].length){
					if(given[significance.get(i).chr_index][j]!=-1){
						redundant=true;
					}
				}
				
			}
			if(!redundant){
				for (int j=significance.get(i).start/2500;j<significance.get(i).end/2500;j++){
					if(j<given[significance.get(i).chr_index].length){
						given[significance.get(i).chr_index][j]=i;
					}
				}
				ArrayList<Integer> narrow2=new ArrayList<Integer>();
				if(significance.get(i).end-significance.get(i).start==10000){
					for (int j=significance.get(i).start/2500;j<significance.get(i).end/2500;j++){
						if(j<fdr_weight[significance.get(i).chr_index].length){
							if(max(fdr_weight[significance.get(i).chr_index][j])<Math.min(0.1,1000*significance.get(i).q)){
								narrow2.add(j);
							}
						}
					}
				}
				else if(significance.get(i).end-significance.get(i).start==100000){
					for (int j=significance.get(i).start/25000;j<significance.get(i).end/25000;j++){
						if(j<fdr_weight_100[significance.get(i).chr_index].length){
							//if(max(fdr_weight_100[significance.get(i).chr_index][j])<=2*significance.get(i).q||max(fdr_weight_100[significance.get(i).chr_index][j])<0.001){
							if(max(fdr_weight_100[significance.get(i).chr_index][j])<Math.min(0.1,1000*significance.get(i).q)){
								for (int k=0;k<10;k++){
									narrow2.add(10*j+k);
								}
							}
						}
						
					}
				}
				
				
				if(narrow2.size()==0){
					for (int j=significance.get(i).start/2500;j<significance.get(i).end/2500;j++){
						if(j<fdr2[significance.get(i).chr_index].length){
							fdr2[significance.get(i).chr_index][j]=significance.get(i).q;
						}
						
					}
				}
				else{
					for (int j=significance.get(i).start/2500;j<significance.get(i).end/2500;j++){
						if(contains(j,narrow2)){
							if(j<fdr2[significance.get(i).chr_index].length){
								fdr2[significance.get(i).chr_index][j]=significance.get(i).q;
							}
							
						}
						else{
							if(j<fdr2[significance.get(i).chr_index].length){
								fdr2[significance.get(i).chr_index][j]=max(fdr_weight[significance.get(i).chr_index][j]);//Math.min(max(fdr[index(sign.get(i).chr,chr)][j]),max(fdr_100[index(sign.get(i).chr,chr)][j/10]));
								
							}
						}
					}
				}
				
			}
		}
		
		
		for (int i=0;i<given.length;i++){
			for (int j=0;j<given[i].length;j++){
				if(given[i][j]==-1){
					fdr2[i][j]=max(fdr_weight[i][j]);
				}
				
			}
		}
		
		
		return fdr2;
		
	}
	
	
	public static boolean contains(int x, ArrayList<Integer> y){
		for (int i=0;i<y.size();i++){
			if(y.get(i)==x){
				return true;
			}
		}
		return false;
	}
	
	
	public static double max(double[] x){
		double m=-Double.MAX_VALUE;
		for (int i=0;i<x.length;i++){
			if(x[i]>m){
				m=x[i];
			}
		}
		return m;
	}
	
	//assign indices of genes to each interval depending on their overlap 
	public static ArrayList<Integer>[][] index_gene(int shift, int width){
		ArrayList<Integer>[][] index_gene=new ArrayList[chr.length][];
		for (int i=0;i<chr.length;i++){
			index_gene[i]=new ArrayList[1+(chr_length[i]-shift)/width];
			for (int j=0;j<index_gene[i].length;j++){
				index_gene[i][j]=new ArrayList<Integer>();
			}
		}
		
		for (int i=0;i<gene_borders.size();i++){
			for (int j=(gene_borders.get(i)[1]-shift)/width;j<=(gene_borders.get(i)[2]-shift)/width;j++){
				index_gene[gene_borders.get(i)[0]][j].add(i);
			}
		}
		return index_gene;
	}
	
	//read list of official gene symbols and initizalize look up tables to assign gene names to their official symbols
	public static void read_symbol_list() throws java.io.IOException {
		{
			java.io.InputStream in=ZipOverlay.fileInputStream(file_symbols);
			BufferedReader input= new BufferedReader(new InputStreamReader(ZipFilter.filterInputStream(in)));
			input.readLine();
			int n=0;
			String s="";
			while((s=input.readLine())!=null){
				String[] t=s.split("	");
				symbol.add(t[0]);
				table.put(t[0],n);
				String[] t1=t[3].split(", ");
				String[] t2=t[4].split(", ");
				if(t1.length>0&&!t1[0].equals("")){
					for (int i=0;i<t1.length;i++){
						table.put(t1[i],n);
					}
				}
				if(t2.length>0&&!t2[0].equals("")){
					for (int i=0;i<t2.length;i++){
						table.put(t2[i],n);
					}
				}
				n++;
			}
			input.close();
		}
	}
	
	//look up the official symbol for a gene name
	public static String symbol(String s){
		int ii=index(s,symbol);
		if(ii!=-1){
			return s;
		}
		Integer a=table.get(s);
		if(a==null){
			return s;
		}
		
		return symbol.get(a);
		
	}
	
	public static int index(String s, ArrayList<String> t){
		for (int i=0;i<t.size();i++){
			if(t.get(i).equals(s)){
				return i;
			}
		}
		return -1;
	}
	
	//load genes genes borders from Hg19 annotation 
	public static void load_genes() throws java.io.IOException {
		
		{
			for (int i=0;i<chr.length;i++){
				
				java.io.InputStream in=ZipOverlay.fileInputStream(file_genes+chr[i]+"_Hg19.bed");
				BufferedReader input= new BufferedReader(new InputStreamReader(ZipFilter.filterInputStream(in)));
				String s="";
				while((s=input.readLine())!=null){
					String[] t=s.split("	");
					String c=t[2].substring(3);
					String gene_name=symbol(t[12]);
					
					if(search_table2.get(gene_name.toUpperCase())==null){
						search_table2.put(gene_name.toUpperCase(),gene_names.size());
						gene_names.add(gene_name.toUpperCase());
						gene_borders.add(new int[]{index(c,chr),Integer.parseInt(t[4])+1,Integer.parseInt(t[5])});
					}
					else{
						Integer ii=search_table2.get(gene_name.toUpperCase());
						if(gene_borders.get(ii)[0]==index(c,chr)){
							if(Integer.parseInt(t[4])+1<gene_borders.get(ii)[1]){
								gene_borders.get(ii)[1]=Integer.parseInt(t[4])+1;
							}
							if(Integer.parseInt(t[5])>gene_borders.get(ii)[2]){
								gene_borders.get(ii)[2]=Integer.parseInt(t[5]);
							}
						}
					}
					
				}
				input.close();
				
			}
			
			
		}
	}
	
	
	//class of gene with gene and genomic borders
	private static class Gene{
		String gene_name="";
		String chr="";
		int start=-1;
		int end=-1;
		String strand="";
		int start_coding=-1;
		int end_coding=-1;
		ArrayList<Exon> exons=new ArrayList<Exon>();
		public Gene(String gene_name,String chr,  ArrayList<Exon> exons, String strand, int start, int end,int start_coding, int end_coding){//, ArrayList<int[]> coding
			this.gene_name=gene_name;
			this.exons=exons;
			//this.coding=coding;
			this.chr=chr;
			this.start=start;
			this.end=end;
			this.strand=strand;
			this.start_coding=start_coding;
			this.end_coding=end_coding;
		}
		
		
	}
	
	//exon with genomic borders
	private static class Exon{
		String chr="";
		int start=0;
		int end=0;
		
		public Exon(String chr, int start, int end){
			this.chr=chr;
			this.start=start;
			this.end=end;
		}
	}
	
	//significant region with annotation of closest gene and expression-based weight for multiple hypotheses correction 
	private static class Sign{
		int chr_index=-1;
		int pos_index=-1;
		double p=1.0;
		double p_weight=1.0;
		double expr=0.0;
		String[] gene_list=null;
		String gene="";
		int group=-1;
		double q_bh=1.0;
		double q_weight=1.0;
		
		public Sign(int chr_index, int pos_index, double p, double expr, String[] gene_list, String gene){
			this.chr_index=chr_index;
			this.pos_index=pos_index;
			this.p=p;
			this.expr=expr;
			this.gene=gene;
			this.gene_list=gene_list;
		}
	}
	
	//significant region with genomic borders 
	private static class Sign2{
		int chr_index=-1;
		int start=0;
		int end=0;
		double q=1.0;
		public Sign2(int chr_index, int start, int end, double q){
			this.chr_index=chr_index;
			this.start=start;
			this.end=end;
			this.q=Math.max(Math.pow(10, -10), q);	
		}
	}
	
	//read significance for 10kb intervals, combine significance values for each interval, and perform weighted multiple hypothesis correction
	public static double[][][][] read_sign_fdr(String entity, double[] max95, boolean expression_available, double[][][] coverage) throws java.io.IOException {
		int[] shift1={0,2500,5000,7500};
		int width=10000;
		double[][][][] fdr=new double[shift1.length][][][];
		
		double[][][] sign=new double[shift1.length][][];
		for (int i=0;i<shift1.length;i++){
			System.out.println(shift1[i]);
			sign[i]=read_sign(entity,shift1[i]);
			
		}
		
	
		for (int i=0;i<shift1.length;i++){
			System.out.println(shift1[i]);
			fdr[i]=fdr_weight(sign[i], max95, shift1[i], width,expression_available,coverage[i]);
		}
		
		double[][][] fdr_bh=new double[chr.length][][];
		double[][][] fdr_weight=new double[chr.length][][];
		for (int i=0;i<chr.length;i++){
			fdr_bh[i]=new double[1+chr_length[i]/2500][shift1.length];
			fdr_weight[i]=new double[1+chr_length[i]/2500][shift1.length];
			for (int j=0;j<fdr_bh[i].length;j++){
				for (int k=0;k<fdr_bh[i][j].length;k++){
					fdr_bh[i][j][k]=1.0;
					fdr_weight[i][j][k]=1.0;
				}
			}
		}
		
		for (int i=0;i<fdr.length;i++){
			for (int j=0;j<fdr[i].length;j++){
				for (int k=0;k<fdr[i][j].length;k++){
					for (int l=(k*10000+shift1[i])/2500;l<(k*10000+10000+shift1[i])/2500;l++){
						if(l<fdr_bh[j].length){
							fdr_bh[j][l][i]=fdr[i][j][k][0];
							fdr_weight[j][l][i]=fdr[i][j][k][1];
						}
					}
				}
			}
		}
		
		return new double[][][][]{sign,fdr_bh,fdr_weight};
	}
	
	//read significance for 100kb intervals, combine significance values for each interval, and perform weighted multiple hypothesis correction
	public static double[][][][] read_sign_fdr_100(String entity, double[] max95, boolean expression_available, boolean[][][] coverage_valid) throws java.io.IOException {
		int width=100000;
		int[] shift2={0,25000,50000,75000};
		
		double[][][] sign=new double[shift2.length][][];
		for (int i=0;i<shift2.length;i++){
			System.out.println(shift2[i]);
			sign[i]=read_sign_100(entity,shift2[i]);
		}
		
		double[][][][] fdr=new double[shift2.length][][][];
		for (int i=0;i<shift2.length;i++){
			System.out.println(shift2[i]);
			fdr[i]=fdr_weight(sign[i], max95, shift2[i], width,expression_available,coverage_valid[i]);
		}
		
		
		double[][][] fdr_bh=new double[chr.length][][];
		double[][][] fdr_weight=new double[chr.length][][];
		for (int i=0;i<chr.length;i++){
			fdr_bh[i]=new double[1+chr_length[i]/25000][shift2.length];
			fdr_weight[i]=new double[1+chr_length[i]/25000][shift2.length];
			for (int j=0;j<fdr_bh[i].length;j++){
				for (int k=0;k<fdr_bh[i][j].length;k++){
					fdr_bh[i][j][k]=1.0;
					fdr_weight[i][j][k]=1.0;
				}
			}
		}
		
		for (int i=0;i<fdr.length;i++){
			for (int j=0;j<fdr[i].length;j++){
				for (int k=0;k<fdr[i][j].length;k++){
					for (int l=(k*100000+shift2[i])/25000;l<(k*100000+100000+shift2[i])/25000;l++){
						if(l<fdr_bh[j].length){
							fdr_bh[j][l][i]=fdr[i][j][k][0];
							fdr_weight[j][l][i]=fdr[i][j][k][1];
						}
					}
				}
			}
		}
		return new double[][][][]{sign,fdr_bh,fdr_weight};
	}
	
	//read cancer type specific expression files and annotate expression to each gene
	public static double[] read_expression(String[] entity2) throws java.io.IOException {
		double[] max95=new double[gene_names.size()];
		for (int i=0;i<max95.length;i++){
			max95[i]=Double.NaN;
		}
		
		{
			Hashtable<String,String> conversion_mir=new Hashtable<String,String>();
			String s="";
			java.io.InputStream in=ZipOverlay.fileInputStream(file_transform_mir);
			BufferedReader input= new BufferedReader(new InputStreamReader(ZipFilter.filterInputStream(in)));
			while((s=input.readLine())!=null){
				String[] t=s.split("	");
				conversion_mir.put(t[0],t[1]);
			}
			input.close();
				
			for (int k=0;k<entity2.length;k++){//path_expression.size()
				if(!ZipOverlay.exists(new File(file_expression+entity2[k]+".txt"))){
					continue;
				}
				
				{ java.io.InputStream in1=ZipOverlay.fileInputStream(file_expression+entity2[k]+".txt");//path_expression.get(k)
				input= new BufferedReader(new InputStreamReader(ZipFilter.filterInputStream(in1))); }
				input.readLine();
				input.readLine();
				while((s=input.readLine())!=null){
					String[] t=s.split("	");
					String g=t[0].split("\\|")[0];

					Integer ii=search_table2.get(symbol(g).toUpperCase());
					if(ii!=null){
						double a=0;
						double n=0;
						double m=0;
						for (int i=1;i<t.length;i++){
							a+=Double.parseDouble(t[i]);
							n++;
							if(Double.parseDouble(t[i])>m){
								m=Double.parseDouble(t[i]);
							}
						}
						if(n>0){
							a/=n;
						}
						ArrayList<Double> xx=new ArrayList<Double>();
						for (int i=1;i<t.length;i++){
							xx.add(Double.parseDouble(t[i]));
						}
						Collections.sort(xx);
						
						double x=xx.get((int)(xx.size()*0.95));
						if(Double.isNaN(max95[ii])||x>max95[ii]){
							max95[ii]=x;//xx.get((int)(xx.size()*0.95));
						}
					}
				}
				input.close();
			}
			
			for (int k=0;k<entity2.length;k++){//path_mir_expression.size()
				if(!ZipOverlay.exists(new File(file_expression+entity2[k]+"_mir.txt"))){
					continue;
				}
				
				{ java.io.InputStream in1=ZipOverlay.fileInputStream(file_expression+entity2[k]+"_mir.txt");//path_mir_expression.get(k)
				input= new BufferedReader(new InputStreamReader(ZipFilter.filterInputStream(in1))); }
				input.readLine();
				input.readLine();
				while((s=input.readLine())!=null){
					String[] t=s.split("	");
					String g=conversion_mir.get(t[0]);
					if(g!=null){
						Integer ii=search_table2.get(symbol(g).toUpperCase());
						if(ii!=null){
							double a=0;
							double n=0;
							double m=0;
							for (int i=2;i<t.length;i+=3){
								a+=Double.parseDouble(t[i]);
								n++;
								if(Double.parseDouble(t[i])>m){
									m=Double.parseDouble(t[i]);
								}
							}
							if(n>0){
								a/=n;
							}
							ArrayList<Double> xx=new ArrayList<Double>();
							for (int i=2;i<t.length;i+=3){
								xx.add(Double.parseDouble(t[i]));
							}
							Collections.sort(xx);
							
							double x=xx.get((int)(xx.size()*0.95));
							if(Double.isNaN(max95[ii])||x>max95[ii]){
								max95[ii]=x;//xx.get((int)(xx.size()*0.95));
							}
						}
						
					}
					
				}
				input.close();
			}
			
		}
		return max95;
	}

	//perform weighted multiple hypothesis correction for 10kb intervals 
	public static double[][][] fdr_weight(double[][] sign,  double[] max95, int shift, int width, boolean expression_available, double[][] coverage){	
		ArrayList<Integer>[][] index_gene=index_gene(shift, width);
		
		ArrayList<Sign> significance=new ArrayList<Sign>();
		for (int i=0;i<sign.length;i++){
			for (int j=0;j<sign[i].length;j++){
				if(low(chr[i])<=coverage[i][j]&&coverage[i][j]<high(chr[i])){
					String[] sss=look_up_array(i,j,index_gene,max_dist,width,max95,search_table2,expression_available);
					double max95_max=0;
					String label_max="";
					if(expression_available){
						if(sss.length>0){
							for (int k=0;k<sss.length;k++){
								Integer ii=search_table2.get(sss[k].toUpperCase());
								if(ii!=null){
									if(max95[ii]>max95_max){
										max95_max=max95[ii];
										label_max=sss[k];
									}
								}
							}
						}
					}
					significance.add(new Sign(i,j,sign[i][j],max95_max,sss,label_max));
				}
				
			}
		}
		
		Comparator<Sign> comp_exp=(Sign s1, Sign s2)->{
			return new Double(s1.expr).compareTo(s2.expr);
		};
		Comparator<Sign> comp_sign=(Sign s1, Sign s2)->{
			return new Double(s1.p).compareTo(s2.p);
		};
		Comparator<Sign> comp_sign_weight=(Sign s1, Sign s2)->{
			return new Double(s1.p_weight).compareTo(s2.p_weight);
		};
		
		if(expression_available){
			Collections.shuffle(significance);
			Collections.sort(significance,comp_exp);
			double[] thresholds_expr=new double[100-1];
			for (int i=0;i<thresholds_expr.length;i++){
				thresholds_expr[i]=significance.get((int)((double)(i+1)/(double)(thresholds_expr.length+1)*significance.size())).expr;
			}
			
			for (int i=0;i<significance.size();i++){
				significance.get(i).group=group(significance.get(i).expr,thresholds_expr);
			}
		}
		
		Collections.shuffle(significance);
		Collections.sort(significance,comp_sign);
		
		for (int i=0;i<significance.size();i++){
			significance.get(i).q_bh=Math.min(1,(double)(significance.size())/(double)(i+1)*significance.get(i).p);
		}
		
		if(expression_available){
			int[] n1=new int[100];
			int[] n2=new int[100];
			int n1_total=0;
			int n2_total=0;
			for (int i=0;i<significance.size();i++){
				if(significance.get(i).q_bh<0.1){
					n1[significance.get(i).group]++;
					n1_total++;
				}
				n2[significance.get(i).group]++;
				n2_total++;
			}
			
			double[] ratio=new double[n1.length];
			int cum_n1=0;
			int cum_n2=0;
			for (int i=n1.length-1;i>=0;i--){
				cum_n1+=n1[i];
				cum_n2+=n2[i];
				
				// NB. assume lhs -> rhs as n -> 0
				double lhs = (double)(cum_n1) / (double)(n1_total);
				double rhs = (double)(cum_n2) / (double)(n2_total);
				ratio[i] = n1_total > 0 && n2_total > 0 ? lhs / rhs : 1.;
			}
			
			double[] ratio_max=new double[ratio.length];
			double avg_ratio=0;
			double avg_ratio_n=0;
			for (int i=0;i<ratio.length;i++){
				double m=0;
				for (int j=0;j<=i;j++){
					if(ratio[j]>m){
						m=ratio[j];
					}
				}
				ratio_max[i]=m;
				avg_ratio+=ratio_max[i]*n2[i];
				avg_ratio_n+=n2[i];
			}
			avg_ratio/=avg_ratio_n;
			
			double[] weight=new double[ratio.length];
			for (int i=0;i<ratio.length;i++){
				weight[i]=ratio_max[i]/avg_ratio;
			}
			
			for (int i=0;i<significance.size();i++){
				significance.get(i).p_weight=Math.min(1, significance.get(i).p/weight[significance.get(i).group]);
			}
			Collections.shuffle(significance);
			Collections.sort(significance,comp_sign_weight);
			for (int i=0;i<significance.size();i++){
				significance.get(i).q_weight=Math.min(1, (double)(significance.size())/(double)(i+1)*significance.get(i).p_weight);
			}
		}
		else{
			for (int i=0;i<significance.size();i++){
				significance.get(i).p_weight=significance.get(i).p;
				significance.get(i).q_weight=significance.get(i).q_bh;
			}
		}
		
		
		double[][][] fdr=new double[sign.length][][];
		for (int i=0;i<chr.length;i++){
			fdr[i]=new double[sign[i].length][2];
			for (int j=0;j<fdr[i].length;j++){
				fdr[i][j][0]=1.0;
				fdr[i][j][1]=1.0;
			}
		}
		for (int i=0;i<significance.size();i++){
			fdr[significance.get(i).chr_index][significance.get(i).pos_index][0]=significance.get(i).q_bh;
			fdr[significance.get(i).chr_index][significance.get(i).pos_index][1]=significance.get(i).q_weight;
		}
		
		return fdr;
	}
	
	//perform weighted multiple hypothesis correction for 100kb intervals
	public static double[][][] fdr_weight(double[][] sign,  double[] max95, int shift, int width, boolean expression_available, boolean[][] coverage_valid){	
		ArrayList<Integer>[][] index_gene=index_gene(shift, width);
		
		ArrayList<Sign> significance=new ArrayList<Sign>();
		for (int i=0;i<sign.length;i++){
			for (int j=0;j<sign[i].length;j++){
				if(coverage_valid[i][j]){
					String[] sss=look_up_array(i,j,index_gene,max_dist,width,max95,search_table2,expression_available);
					double max95_max=0;
					String label_max="";
					if(expression_available){
						if(sss.length>0){
							for (int k=0;k<sss.length;k++){
								Integer ii=search_table2.get(sss[k].toUpperCase());
								if(ii!=null){
									if(max95[ii]>max95_max){
										max95_max=max95[ii];
										label_max=sss[k];
									}
								}
							}
						}
					}
					significance.add(new Sign(i,j,sign[i][j],max95_max,sss,label_max));
				}
				
			}
		}
		
		Comparator<Sign> comp_exp=(Sign s1, Sign s2)->{
			return new Double(s1.expr).compareTo(s2.expr);
		};
		Comparator<Sign> comp_sign=(Sign s1, Sign s2)->{
			return new Double(s1.p).compareTo(s2.p);
		};
		Comparator<Sign> comp_sign_weight=(Sign s1, Sign s2)->{
			return new Double(s1.p_weight).compareTo(s2.p_weight);
		};
		
		if(expression_available){
			Collections.shuffle(significance);
			Collections.sort(significance,comp_exp);
			double[] thresholds_expr=new double[100-1];
			for (int i=0;i<thresholds_expr.length;i++){
				thresholds_expr[i]=significance.get((int)((double)(i+1)/(double)(thresholds_expr.length+1)*significance.size())).expr;
			}
			
			for (int i=0;i<significance.size();i++){
				significance.get(i).group=group(significance.get(i).expr,thresholds_expr);
			}
		}
		
		Collections.shuffle(significance);
		Collections.sort(significance,comp_sign);
		
		for (int i=0;i<significance.size();i++){
			significance.get(i).q_bh=Math.min(1,(double)(significance.size())/(double)(i+1)*significance.get(i).p);
		}
		
		if(expression_available){
			int[] n1=new int[100];
			int[] n2=new int[100];
			int n1_total=0;
			int n2_total=0;
			for (int i=0;i<significance.size();i++){
				if(significance.get(i).q_bh<0.1){
					n1[significance.get(i).group]++;
					n1_total++;
				}
				n2[significance.get(i).group]++;
				n2_total++;
			}
			
			double[] ratio=new double[n1.length];
			int cum_n1=0;
			int cum_n2=0;
			for (int i=n1.length-1;i>=0;i--){
				cum_n1+=n1[i];
				cum_n2+=n2[i];
				
				double lhs = (double)(cum_n1) / (double)(n1_total);
				double rhs = (double)(cum_n2) / (double)(n2_total);
				ratio[i] = n1_total > 0 && n2_total > 0 ? lhs / rhs : 1.;
			}
			
			double[] ratio_max=new double[ratio.length];
			double avg_ratio=0;
			double avg_ratio_n=0;
			for (int i=0;i<ratio.length;i++){
				double m=0;
				for (int j=0;j<=i;j++){
					if(ratio[j]>m){
						m=ratio[j];
					}
				}
				ratio_max[i]=m;
				avg_ratio+=ratio_max[i]*n2[i];
				avg_ratio_n+=n2[i];
			}
			avg_ratio/=avg_ratio_n;
			
			double[] weight=new double[ratio.length];
			for (int i=0;i<ratio.length;i++){
				weight[i]=ratio_max[i]/avg_ratio;
			}
			
			
			for (int i=0;i<significance.size();i++){
				significance.get(i).p_weight=Math.min(1, significance.get(i).p/weight[significance.get(i).group]);
			}
			Collections.shuffle(significance);
			Collections.sort(significance,comp_sign_weight);
			for (int i=0;i<significance.size();i++){
				significance.get(i).q_weight=Math.min(1, (double)(significance.size())/(double)(i+1)*significance.get(i).p_weight);
			}
		}
		else{
			for (int i=0;i<significance.size();i++){
				significance.get(i).p_weight=significance.get(i).p;
				significance.get(i).q_weight=significance.get(i).q_bh;
			}
		}
		
		
		double[][][] fdr=new double[sign.length][][];
		for (int i=0;i<chr.length;i++){
			fdr[i]=new double[sign[i].length][2];
			for (int j=0;j<fdr[i].length;j++){
				fdr[i][j][0]=1.0;
				fdr[i][j][1]=1.0;
			}
		}
		for (int i=0;i<significance.size();i++){
			fdr[significance.get(i).chr_index][significance.get(i).pos_index][0]=significance.get(i).q_bh;
			fdr[significance.get(i).chr_index][significance.get(i).pos_index][1]=significance.get(i).q_weight;
		}
		
		return fdr;
	}
	
	//lower coverage threshold based on gnomAD
	public static double low(String chr){
		if(chr.equals("X")){
			return 0.11;
		}
		else if(chr.equals("19")){
			return 0.35;
		}
		else{
			return 0.4;
		}
	}
	
	//upper coverage threshold based on gnomAD
	public static double high(String chr){
		if(chr.equals("X")){
			return 0.25;
		}
		else if(chr.equals("19")){
			return 0.62;
		}
		else{
			return 0.62;
		}
	}
	
	//identify the closest gene for each genomic position
	public static String[] look_up_array(int chr_index, int pos_index, ArrayList<Integer>[][] index_gene, int max_dist, int width, double[] max95, Hashtable<String,Integer> search_table, boolean expression_available){
		ArrayList<String> names=new ArrayList<String>();
		int mir=0;
		for(int k=0;k<index_gene[chr_index][pos_index].size();k++){
			Integer ii=search_table2.get(gene_names.get(index_gene[chr_index][pos_index].get(k)).toUpperCase());
			if((expression_available&&ii!=null&&max95[ii]>0)||(!expression_available&&ii!=null)){
				if(gene_names.get(index_gene[chr_index][pos_index].get(k)).subSequence(0, Math.min(gene_names.get(index_gene[chr_index][pos_index].get(k)).length(),3)).equals("MIR")){
					mir++;
				}
				if(gene_names.get(index_gene[chr_index][pos_index].get(k)).subSequence(0, Math.min(gene_names.get(index_gene[chr_index][pos_index].get(k)).length(),4)).equals("LINC")){
					continue;
				}
				if(gene_names.get(index_gene[chr_index][pos_index].get(k)).subSequence(0, Math.min(gene_names.get(index_gene[chr_index][pos_index].get(k)).length(),3)).equals("LOC")){
					continue;
				}
				if(gene_names.get(index_gene[chr_index][pos_index].get(k)).indexOf("-AS")!=-1){
					continue;
				}
				
				if(!contains(gene_names.get(index_gene[chr_index][pos_index].get(k)),names)){
					names.add(gene_names.get(index_gene[chr_index][pos_index].get(k)));
				}
			}
			
		}
		
		if (names.size()-mir==0){
			int l=1;
			boolean added=false;
			while (pos_index-l>=0&&!added&&l*width<=max_dist){//5000000
				for(int k=0;k<index_gene[chr_index][pos_index-l].size();k++){
					Integer ii=search_table2.get(gene_names.get(index_gene[chr_index][pos_index-l].get(k)).toUpperCase());
					if((expression_available&&ii!=null&&max95[ii]>0)||(!expression_available&&ii!=null)){
						if(gene_names.get(index_gene[chr_index][pos_index-l].get(k)).subSequence(0, Math.min(gene_names.get(index_gene[chr_index][pos_index-l].get(k)).length(),3)).equals("MIR")){
							mir++;
						}
						if(gene_names.get(index_gene[chr_index][pos_index-l].get(k)).subSequence(0, Math.min(gene_names.get(index_gene[chr_index][pos_index-l].get(k)).length(),4)).equals("LINC")){
							continue;
						}
						if(gene_names.get(index_gene[chr_index][pos_index-l].get(k)).subSequence(0, Math.min(gene_names.get(index_gene[chr_index][pos_index-l].get(k)).length(),3)).equals("LOC")){
							continue;
						}
						if(gene_names.get(index_gene[chr_index][pos_index-l].get(k)).indexOf("-AS")!=-1){
							continue;
						}
						
						if(!contains(gene_names.get(index_gene[chr_index][pos_index-l].get(k)),names)){
							names.add(gene_names.get(index_gene[chr_index][pos_index-l].get(k)));
							added=true;
						}
					}				
				}
				l++;
			}
			l=1;
			added=false;
			while (pos_index+l<index_gene[chr_index].length&&!added&&l*width<=max_dist){//5000000
				for(int k=0;k<index_gene[chr_index][pos_index+l].size();k++){
					Integer ii=search_table2.get(gene_names.get(index_gene[chr_index][pos_index+l].get(k)).toUpperCase());
					if((expression_available&&ii!=null&&max95[ii]>0)||(!expression_available&&ii!=null)){
						if(gene_names.get(index_gene[chr_index][pos_index+l].get(k)).subSequence(0, Math.min(gene_names.get(index_gene[chr_index][pos_index+l].get(k)).length(),3)).equals("MIR")){
							mir++;
						}
						if(gene_names.get(index_gene[chr_index][pos_index+l].get(k)).subSequence(0, Math.min(gene_names.get(index_gene[chr_index][pos_index+l].get(k)).length(),4)).equals("LINC")){
							continue;
						}
						if(gene_names.get(index_gene[chr_index][pos_index+l].get(k)).subSequence(0, Math.min(gene_names.get(index_gene[chr_index][pos_index+l].get(k)).length(),3)).equals("LOC")){
							continue;
						}
						if(gene_names.get(index_gene[chr_index][pos_index+l].get(k)).indexOf("-AS")!=-1){
							continue;
						}
						
						if(!contains(gene_names.get(index_gene[chr_index][pos_index+l].get(k)),names)){
							names.add(gene_names.get(index_gene[chr_index][pos_index+l].get(k)));
							added=true;
						}
						
					}
				}
				l++;
			}
			
		}
		
		if(names.size()==0){
			return new String[0];
		}
		String[] s=new String[names.size()];
		for (int k=0;k<names.size();k++){
			s[k]=names.get(k);
			
		}
		return s;
	}
	
	
	public static boolean contains(String s, ArrayList<String> t){
		for (int i=0;i<t.size();i++){
			if(t.get(i).equals(s)){
				return true;
			}
		}
		return false;
	}
	
	//for weighted multiple hypothesis correction, assign the group of the hypothesis based on its expression
	public static int group(double x, double[] threshold){
		if(x<threshold[0]){
			return 0;
		}
		else if(x>=threshold[threshold.length-1]){
			return threshold.length;
		}
		for (int i=1;i<threshold.length;i++){
			if(threshold[i-1]<=x&&x<threshold[i]){
				return i;
			}
		}
		return -1;
	}
	
	//combined significance values of 10kb intervals to one combined significance value per interval using Brown's method
	public static double[][] read_sign(String entity, int shift) throws java.io.IOException {
		{
			String[] files_clumps={
					folder_auxiliary+entity+"_10kb_"+shift+separator+"ClumpsCountCombi.txt"+SignificanceNoncoding.out_suffix,
					folder_auxiliary+entity+"_10kb_"+shift+separator+"ClumpsCountCombiIndel.txt"+SignificanceNoncoding.out_suffix
			};
			
			String[] files_count={
					folder_auxiliary+entity+"_10kb_"+shift+separator+"CountIndel1.txt"+SignificanceNoncoding.out_suffix,//p_indel_min	
					folder_auxiliary+entity+"_10kb_"+shift+separator+"CountIndel2.txt"+SignificanceNoncoding.out_suffix,//p_indel_large	
					folder_auxiliary+entity+"_10kb_"+shift+separator+"CountCombi1.txt"+SignificanceNoncoding.out_suffix,//p_combi_min	
					folder_auxiliary+entity+"_10kb_"+shift+separator+"CountCombi2.txt"+SignificanceNoncoding.out_suffix,//p_combi_large	
					folder_auxiliary+entity+"_10kb_"+shift+separator+"EpigenomicIndel1.txt"+SignificanceNoncoding.out_suffix,//sign_epigenomic_indel_large	
					folder_auxiliary+entity+"_10kb_"+shift+separator+"EpigenomicIndel2.txt"+SignificanceNoncoding.out_suffix,//sign_epigenomic_indel_min	
					folder_auxiliary+entity+"_10kb_"+shift+separator+"EpigenomicCombi1.txt"+SignificanceNoncoding.out_suffix,//sign_epigenomic_combi_large	
					folder_auxiliary+entity+"_10kb_"+shift+separator+"EpigenomicCombi2.txt"+SignificanceNoncoding.out_suffix,//sign_epigenomic_combi_min
			
			};
			
			double[] threshold_count={
					1,//p_indel_min	
					1,//p_indel_large	
					6,//p_combi_min	
					8,//p_combi_large	
					1,//sign_epigenomic_indel_large	
					1,//sign_epigenomic_indel_min	
					8,//sign_epigenomic_combi_large	
					6,//sign_epigenomic_combi_min	
			};
			
			int[] files_count_dim={
					1000,//p_indel_min	
					10000,//p_indel_large	
					1000,//p_combi_min	
					10000,//p_combi_large	
					10000,//sign_epigenomic_indel_large	
					1000,//sign_epigenomic_indel_min	
					10000,//sign_epigenomic_combi_large	
					1000,//sign_epigenomic_combi_min
			};
			
			double[][][] count=new double[threshold_count.length][][];
			for (int k=0;k<files_count.length;k++){
				if(files_count_dim[k]==1000){
					count[k]=read_count_1000(files_count[k],shift);
				}
				else if(files_count_dim[k]==10000){
					count[k]=read_count_10000(files_count[k],shift);
				}
			}
			
					
			double[][][] sign=new double[chr.length][][];
			double[][][] clumps=new double[chr.length][][];
			double[][][] clumps_avg=new double[chr.length][][];
			for (int i=0;i<chr.length;i++){
				sign[i]=new double[1+(chr_length[i]-shift)/10000][13];
				clumps[i]=new double[1+(chr_length[i]-shift)/10000][2];
				clumps_avg[i]=new double[1+(chr_length[i]-shift)/10000][2];
				for (int j=0;j<sign[i].length;j++){
					for (int k=0;k<sign[i][j].length;k++){
						sign[i][j][k]=1.0;
					}
				}
			}
			
			for (int k=0;k<files_clumps.length;k++){
				FileInputStream in=new FileInputStream(files_clumps[k]);
				BufferedReader input= new BufferedReader(new InputStreamReader(ZipFilter.filterInputStream(in)));
				String s="";
				while((s=input.readLine())!=null){
					String[] t=s.split("	");
					clumps[Integer.parseInt(t[0])][Integer.parseInt(t[1])][k]=Double.parseDouble(t[2]);
					clumps_avg[Integer.parseInt(t[0])][Integer.parseInt(t[1])][k]=Double.parseDouble(t[3]);
				}
				input.close();
			}
			
			FileInputStream in=new FileInputStream(folder_significance+"Significance_"+entity+"_"+shift+".txt"+SignificanceNoncoding.out_suffix);
			BufferedReader input= new BufferedReader(new InputStreamReader(ZipFilter.filterInputStream(in)));
			input.readLine();
			String s="";
			while((s=input.readLine())!=null){
				String[] t=s.split("	");
				for (int k=0;k<13;k++){
					if(index(t[0],chr)==-1){
						System.out.println(t[0]);
					}
					sign[index(t[0],chr)][(Integer.parseInt(t[1])-shift)/10000][k]=Double.parseDouble(t[k+2]);
				}
			}
			input.close();
	
			double aavg, var, aavgX, varX;
			{
				MVNEstimator est = new MVNEstimator( 13+4 );
				double[] x = new double[est.dim()];

				MVNEstimator estX = new MVNEstimator( 13+4 );
				double[] xX = new double[estX.dim()];

			for (int i=0;i<sign.length;i++){
				for (int j=0;j<sign[i].length;j++){
					double product=productValues(x, sign[i][j]);
					double productX=productXValues(xX, sign[i][j]);
					
					if(0<product&&product<1){
						for (int k=0;k<x.length;k++)
							x[k]=-2*Math.log(x[k]);
						est.update(x);
					}
					if(0<productX&&productX<1){
						for (int k=0;k<xX.length;k++)
							xX[k]=-2*Math.log(xX[k]);
						estX.update(xX);
					}
				}
			}

				aavg = 2 * est.dim();
				var = 4 * sum( est.cor() ); // NB. 4 * est.dim() for independent

				aavgX = 2 * estX.dim();
				varX = 4 * sum( estX.cor() );
			}
			
			double cc=var/(2*aavg);
			double kk=2*aavg*aavg/var;
			
			double ccX=varX/(2*aavgX);
			double kkX=2*aavgX*aavgX/varX;
			
			for (int i=0;i<sign.length;i++){
				for (int j=0;j<sign[i].length;j++){
					for (int k=0;k<clumps_avg[i][j].length;k++){
						if(clumps[i][j][k]>2.5*clumps_avg[i][j][k]&&clumps_avg[i][j][k]>1){
							
						}
						else{
							sign[i][j][k+1]=1;//Math.random();
							//fdr[i][j][k+2]=1;
						}
					}
					
					for (int k=0;k<threshold_count.length;k++){
						if(count[k][i][j]>threshold_count[k]){
							
						}
						else{
							sign[i][j][k+3]=1;
						}
					}
					
				}
			}
			
			
			
			ChiSquaredDistribution dist=new ChiSquaredDistribution(kk);
			ChiSquaredDistribution distX=new ChiSquaredDistribution(kkX);
			double[][] sign_final=new double[chr.length][];
			double[][] sign_finalX=new double[chr.length][];
			for (int i=0;i<sign.length;i++){
				sign_final[i]=new double[sign[i].length];
				sign_finalX[i]=new double[sign[i].length];
				for (int j=0;j<sign[i].length;j++){
					double product=product(sign[i][j]);
					double productX=productX(sign[i][j]);
					
					double product_final=1;
					if(product<=0){
						product_final=0;
					}
					else if(0<product&&product<1){
						product_final=1-dist.cumulativeProbability(-2*Math.log(product)/cc);
					}
					else if(product>=1){
						product_final=1;
					}
					
					double product_finalX=1;
					if(productX<=0){
						product_finalX=0;
					}
					else if(0<productX&&productX<1){
						product_finalX=1-distX.cumulativeProbability(-2*Math.log(productX)/ccX);
					}
					else if(productX>=1){
						product_finalX=1;
					}
					sign_final[i][j]=product_final;
					sign_finalX[i][j]=product_finalX;
				}
			}

			ArrayList<double[]> x=new ArrayList<double[]>();
			double[][] q=new double[sign_final.length][];
			for (int i=0;i<sign_final.length;i++){
				q[i]=new double[sign_final[i].length];
				for (int j=0;j<sign_final[i].length;j++){
					q[i][j]=1.0;
					if(sign_final[i][j]<1){				//TODO
						x.add(new double[]{i,j,sign_final[i][j]});
					}
				}
			}
			
			Comparator<double[]> comp=(double[] a, double[] b)->{
				return new Double(a[2]).compareTo(b[2]);
			};
			
			Collections.sort(x,comp);
			for (int i=0;i<x.size();i++){
				q[(int)(x.get(i)[0])][(int)(x.get(i)[1])]=x.get(i)[2]*(double)(x.size())/(double)(i+1);
			}
			
			return sign_final;
			
		}
		
	}
	
	//auxiliary method for combining p-values if 10kb intervals
	public static double product(double[] x){
		int[] index_sel={0,1,2,3,4,5,6,7,8,9,10,11,12};
						 
		double product=1;
		for (int i=0;i<index_sel.length;i++){
			product*=x[index_sel[i]];
		}
		product*=x[11]*x[1]*x[2]*x[12];
		
		return product;
	}
	protected static double _productValues(double[] x_sel, double[] x, int[] index_sel, int[] aux_sel){
		int t=0;

		double product=1;
		for (int i=0;i<index_sel.length;i++){
			x_sel[t++]=x[index_sel[i]];
			product*=x[index_sel[i]];
		}
		double product_aux=1;
		for (int i=0;i<aux_sel.length;i++){
			x_sel[t++]=x[aux_sel[i]];
			product_aux*=x[aux_sel[i]];
		}
		product*=product_aux;

		return product;
	}
	public static double productValues(double[] x_sel, double[] x){
		return _productValues(x_sel, x, new int[]{0,1,2,3,4,5,6,7,8,9,10,11,12}, new int[]{11,1,2,12});
	}
	
	//auxiliary method for combining p-values if 100kb intervals
	public static double product100(double[] x){
		int[] index_sel={0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16};
			
		double product=1;
		for (int i=0;i<index_sel.length;i++){
			product*=x[index_sel[i]];
		}
		product*=x[15]*x[1]*x[2]*x[16];
		return product;
	}
	public static double product100Values(double[] x_sel, double x[]){
		return _productValues(x_sel, x, new int[]{0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16}, new int[]{15,1,2,16});
	}

	//auxiliary method for combining p-values if 10kb intervals
	public static double productX(double[] x){
		int[] index_sel={0,1,2,3,4,5,6,7,8,9,10,11,12};
		
		double product=1;
		for (int i=0;i<index_sel.length;i++){
			product*=x[index_sel[i]];
		}
		product*=x[11]*x[1]*x[2]*x[12];
		return product;
	}
	public static double productXValues(double[] x_sel, double[] x) {
		return _productValues(x_sel, x, new int[]{0,1,2,3,4,5,6,7,8,9,10,11,12}, new int[]{11,1,2,12});
	}

	//auxiliary method for combining p-values if 100kb intervals
	public static double product100X(double[] x){
		int[] index_sel={0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16};
						 
		double product=1;
		for (int i=0;i<index_sel.length;i++){
			product*=x[index_sel[i]];
		}
		product*=x[15]*x[1]*x[2]*x[16];
		return product;
	}
	public static double product100XValues(double[] x_sel, double[] x) {
		return _productValues(x_sel, x, new int[]{0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16}, new int[]{15,1,2,16});
	}
	
	//combined significance values of 100kb intervals to one combined significance value per interval using Brown's method
	public static double[][] read_sign_100(String entity, int shift) throws java.io.IOException {
		{
			String[] files_clumps={
					folder_auxiliary+entity+"_100kb_"+shift+separator+"ClumpsCountCombi_100.txt"+SignificanceNoncoding.out_suffix,
					folder_auxiliary+entity+"_100kb_"+shift+separator+"ClumpsCountCombiIndel_100.txt"+SignificanceNoncoding.out_suffix
			};
					
			
			
			
			
			String[] files_count_100={
					folder_auxiliary+entity+"_100kb_"+shift+separator+"CountIndel1_100.txt"+SignificanceNoncoding.out_suffix,//p_indel_min_10fold	
					folder_auxiliary+entity+"_100kb_"+shift+separator+"CountIndel3_100.txt"+SignificanceNoncoding.out_suffix,//p_indel_min_100fold	
					folder_auxiliary+entity+"_100kb_"+shift+separator+"CountIndel2_100.txt"+SignificanceNoncoding.out_suffix,//p_indel_large	
					folder_auxiliary+entity+"_100kb_"+shift+separator+"CountCombi1_100.txt"+SignificanceNoncoding.out_suffix,//p_combi_min_10fold	
					folder_auxiliary+entity+"_100kb_"+shift+separator+"CountCombi3_100.txt"+SignificanceNoncoding.out_suffix,//p_combi_min_100fold	
					folder_auxiliary+entity+"_100kb_"+shift+separator+"CountCombi2_100.txt"+SignificanceNoncoding.out_suffix,//p_combi_large	
					folder_auxiliary+entity+"_100kb_"+shift+separator+"EpigenomicCombi1_100.txt"+SignificanceNoncoding.out_suffix,//sign_epigenomic_combi_large	
					folder_auxiliary+entity+"_100kb_"+shift+separator+"EpigenomicCombi2_100.txt"+SignificanceNoncoding.out_suffix,//sign_epigenomic_combi_10fold	
					folder_auxiliary+entity+"_100kb_"+shift+separator+"EpigenomicCombi3_100.txt"+SignificanceNoncoding.out_suffix,//sign_epigenomic_combi_100fold	
					folder_auxiliary+entity+"_100kb_"+shift+separator+"EpigenomicIndel1_100.txt"+SignificanceNoncoding.out_suffix,//sign_epigenomic_indel_large	
					folder_auxiliary+entity+"_100kb_"+shift+separator+"EpigenomicIndel2_100.txt"+SignificanceNoncoding.out_suffix,//sign_epigenomic_indel_10fold	
					folder_auxiliary+entity+"_100kb_"+shift+separator+"EpigenomicIndel3_100.txt"+SignificanceNoncoding.out_suffix,//sign_epigenomic_indel_100fold	
			};
			
			int[] files_count_100_dim={
					10000,//p_indel_min_10fold	
					1000,//p_indel_min_100fold	
					100000,//p_indel_large	
					10000,//p_combi_min_10fold	
					1000,//p_combi_min_100fold	
					100000,//p_combi_large	
					100000,//sign_epigenomic_combi_large	
					10000,//sign_epigenomic_combi_10fold	
					1000,//sign_epigenomic_combi_100fold	
					100000,//sign_epigenomic_indel_large	
					10000,//sign_epigenomic_indel_10fold	
					1000,//sign_epigenomic_indel_100fold	
			};
			
			double[] threshold_count_100={
					1,//p_indel_min_10fold	
					1,//p_indel_min_100fold	
					1,//p_indel_large	
					8,//p_combi_min_10fold	
					6,//p_combi_min_100fold	
					20,//p_combi_large	
					20,//sign_epigenomic_combi_large	
					8,//sign_epigenomic_combi_10fold	
					6,//sign_epigenomic_combi_100fold	
					1,//sign_epigenomic_indel_large	
					1,//sign_epigenomic_indel_10fold	
					1,//sign_epigenomic_indel_100fold	
			};
			
			
			
			double[][][] count_100=new double[threshold_count_100.length][][];
			for (int k=0;k<files_count_100.length;k++){
				if(files_count_100_dim[k]==1000){
					count_100[k]=read_100_count_1000(files_count_100[k],shift);
				}
				else if(files_count_100_dim[k]==10000){
					count_100[k]=read_100_count_10000(files_count_100[k],shift);
				}
				else if(files_count_100_dim[k]==100000){
					count_100[k]=read_100_count_100000(files_count_100[k],shift);
				}
			}
			
			double[][][] sign=new double[chr.length][][];
			double[][][] clumps=new double[chr.length][][];
			double[][][] clumps_avg=new double[chr.length][][];
			for (int i=0;i<chr.length;i++){
				sign[i]=new double[1+(chr_length[i]-shift)/100000][17];
				clumps[i]=new double[1+(chr_length[i]-shift)/100000][2];
				clumps_avg[i]=new double[1+(chr_length[i]-shift)/100000][2];
				for (int j=0;j<sign[i].length;j++){
					for (int k=0;k<sign[i][j].length;k++){
						sign[i][j][k]=1.0;
					}
				}
			}
			
			for (int k=0;k<files_clumps.length;k++){
				FileInputStream in=new FileInputStream(files_clumps[k]);
				BufferedReader input= new BufferedReader(new InputStreamReader(ZipFilter.filterInputStream(in)));
				String s="";
				while((s=input.readLine())!=null){
					String[] t=s.split("	");
					clumps[Integer.parseInt(t[0])][Integer.parseInt(t[1])][k]=Double.parseDouble(t[2]);
					clumps_avg[Integer.parseInt(t[0])][Integer.parseInt(t[1])][k]=Double.parseDouble(t[3]);
				}
				input.close();
			}
			
			FileInputStream in=new FileInputStream(folder_significance+"Significance_100_"+entity+"_"+shift+".txt"+SignificanceNoncoding.out_suffix);
			BufferedReader input= new BufferedReader(new InputStreamReader(ZipFilter.filterInputStream(in)));
			input.readLine();
			String s="";
			while((s=input.readLine())!=null){
				String[] t=s.split("	");
				for (int k=0;k<17;k++){
					if(index(t[0],chr)==-1){
						System.out.println(t[0]);
					}
					sign[index(t[0],chr)][(Integer.parseInt(t[1])-shift)/100000][k]=Double.parseDouble(t[k+2]);
				}
			}
			input.close();

			double aavg, var, aavgX, varX;
			{
				MVNEstimator est = new MVNEstimator( 17+4 );
				double[] x = new double[est.dim()];

				MVNEstimator estX = new MVNEstimator( 17+4 );
				double[] xX = new double[estX.dim()];
			
			for (int i=0;i<sign.length;i++){
				for (int j=0;j<sign[i].length;j++){
					double product=product100Values(x, sign[i][j]);
					double productX=product100XValues(xX, sign[i][j]);
					
					if(0<product&&product<1){
						for (int k=0;k<x.length;k++)
							x[k]=-2*Math.log(x[k]);
						est.update(x);
					}
					if(0<productX&&productX<1){
						for (int k=0;k<xX.length;k++)
							xX[k]=-2*Math.log(xX[k]);
						estX.update(xX);
					}
				}
			}

				aavg = 2 * est.dim();
				var = 4 * sum( est.cor() );

				aavgX = 2 * estX.dim();
				varX = 4 * sum( estX.cor() );
			}
			
			double cc=var/(2*aavg);
			double kk=2*aavg*aavg/var;
			double ccX=varX/(2*aavgX);
			double kkX=2*aavgX*aavgX/varX;
			
			
			for (int i=0;i<sign.length;i++){
				for (int j=0;j<sign[i].length;j++){
					for (int k=0;k<clumps_avg[i][j].length;k++){
						if(clumps[i][j][k]>2.5*clumps_avg[i][j][k]&&clumps_avg[i][j][k]>1){
							
						}
						else{
							sign[i][j][k+1]=1;//Math.random();
						}
					}
					
					for (int k=0;k<threshold_count_100.length;k++){
						if(count_100[k][i][j]>threshold_count_100[k]){
							
						}
						else{
							sign[i][j][k+3]=1;
						}
					}
					
				}
			}
			
			
			ChiSquaredDistribution dist=new ChiSquaredDistribution(kk);
			ChiSquaredDistribution distX=new ChiSquaredDistribution(kkX);
			double[][] sign_final=new double[chr.length][];
			double[][] sign_finalX=new double[chr.length][];
			for (int i=0;i<sign.length;i++){
				sign_final[i]=new double[sign[i].length];
				sign_finalX[i]=new double[sign[i].length];
				for (int j=0;j<sign[i].length;j++){
					double product=product100(sign[i][j]);
					double productX=product100X(sign[i][j]);
					
					double product_final=1;
					if(product<=0){
						product_final=0;
					}
					else if(0<product&&product<1){
						product_final=1-dist.cumulativeProbability(-2*Math.log(product)/cc);
					}
					else if(product>=1){
						product_final=1;
					}
					double product_finalX=1;
					if(productX<=0){
						product_finalX=0;
					}
					else if(0<productX&&productX<1){
						product_finalX=1-distX.cumulativeProbability(-2*Math.log(productX)/ccX);
					}
					else if(productX>=1){
						product_finalX=1;
					}
					
					sign_final[i][j]=product_final;
					sign_finalX[i][j]=product_finalX;
				}
			}
			
			ArrayList<double[]> x=new ArrayList<double[]>();
			double[][] q=new double[sign_final.length][];
			for (int i=0;i<sign_final.length;i++){
				q[i]=new double[sign_final[i].length];
				for (int j=0;j<sign_final[i].length;j++){
					q[i][j]=1.0;
					if(sign_final[i][j]<1){			//TODO
						x.add(new double[]{i,j,sign_final[i][j]});
					}
				}
			}
			
			Comparator<double[]> comp=(double[] a, double[] b)->{
				return new Double(a[2]).compareTo(b[2]);
			};
			
			Collections.sort(x,comp);
			for (int i=0;i<x.size();i++){
				q[(int)(x.get(i)[0])][(int)(x.get(i)[1])]=x.get(i)[2]*(double)(x.size())/(double)(i+1);
			}
			
			return sign_final;
			
		}
		
	}
	
	//read max mutation counts of 1kb intervals per 10kb interval
	public static double[][] read_count_1000(String file, int shift) throws java.io.IOException {
		double[][] count=new double[chr.length][];
		for (int i=0;i<chr.length;i++){
			count[i]=new double[1+(chr_length[i]-shift)/10000];
		}
		{
			FileInputStream in=new FileInputStream(file);
			BufferedReader input= new BufferedReader(new InputStreamReader(ZipFilter.filterInputStream(in)));
			String s="";
			while((s=input.readLine())!=null){
				String[] t=s.split("	");
				if(count[Integer.parseInt(t[0])][Integer.parseInt(t[1])/10]<=Double.parseDouble(t[2])){
					count[Integer.parseInt(t[0])][Integer.parseInt(t[1])/10]=Double.parseDouble(t[2]);
				}
			}
			input.close();
		}
		return count;
	}
	
	//read mutation counts of 10kb intervals
	public static double[][] read_count_10000(String file, int shift) throws java.io.IOException {
		double[][] count=new double[chr.length][];
		for (int i=0;i<chr.length;i++){
			count[i]=new double[1+(chr_length[i]-shift)/10000];
		}
		{
			FileInputStream in=new FileInputStream(file);
			BufferedReader input= new BufferedReader(new InputStreamReader(ZipFilter.filterInputStream(in)));
			String s="";
			while((s=input.readLine())!=null){
				String[] t=s.split("	");
				count[Integer.parseInt(t[0])][Integer.parseInt(t[1])]=Double.parseDouble(t[2]);
			}
			input.close();
		}
		return count;
	}
	
	//read max mutation counts of 1kb intervals per 100kb interval
	public static double[][] read_100_count_1000(String file, int shift) throws java.io.IOException {
		double[][] count=new double[chr.length][];
		for (int i=0;i<chr.length;i++){
			count[i]=new double[1+(chr_length[i]-shift)/100000];
		}
		{
			FileInputStream in=new FileInputStream(file);
			BufferedReader input= new BufferedReader(new InputStreamReader(ZipFilter.filterInputStream(in)));
			String s="";
			while((s=input.readLine())!=null){
				String[] t=s.split("	");
				if(count[Integer.parseInt(t[0])][Integer.parseInt(t[1])/100]<=Double.parseDouble(t[2])){
					count[Integer.parseInt(t[0])][Integer.parseInt(t[1])/100]=Double.parseDouble(t[2]);
				}
			}
			input.close();
		}
		return count;
	}
	
	//read max mutation counts of 10kb intervals per 100kb interval
	public static double[][] read_100_count_10000(String file, int shift) throws java.io.IOException {
		double[][] count=new double[chr.length][];
		for (int i=0;i<chr.length;i++){
			count[i]=new double[1+(chr_length[i]-shift)/100000];
		}
		{
			FileInputStream in=new FileInputStream(file);
			BufferedReader input= new BufferedReader(new InputStreamReader(ZipFilter.filterInputStream(in)));
			String s="";
			while((s=input.readLine())!=null){
				String[] t=s.split("	");
				if(count[Integer.parseInt(t[0])][Integer.parseInt(t[1])/10]<=Double.parseDouble(t[2])){
					count[Integer.parseInt(t[0])][Integer.parseInt(t[1])/10]=Double.parseDouble(t[2]);
				}
			}
			input.close();
		}
		return count;
	}
	
	//read mutation counts of 100kb intervals
	public static double[][] read_100_count_100000(String file, int shift) throws java.io.IOException {
		double[][] count=new double[chr.length][];
		for (int i=0;i<chr.length;i++){
			count[i]=new double[1+(chr_length[i]-shift)/100000];
		}
		{
			FileInputStream in=new FileInputStream(file);
			BufferedReader input= new BufferedReader(new InputStreamReader(ZipFilter.filterInputStream(in)));
			String s="";
			while((s=input.readLine())!=null){
				String[] t=s.split("	");
				count[Integer.parseInt(t[0])][Integer.parseInt(t[1])]=Double.parseDouble(t[2]);
			}
			input.close();
		}
		return count;
	}
	
	public static int index(String s, String[] t){
		for (int i=0;i<t.length;i++){
			if(t[i].equals(s)){
				return i;
			}
		}
		return -1;
	}
	
	protected static double sum(double[] x) {
		double s = 0.;
		for (int i = 0; i < x.length; ++i)
			s += x[i];
		return s;
	}

	protected static double sum(double[][] X) {
		double s = 0.;
		for (int i = 0; i < X.length; ++i)
			s += sum(X[i]);
		return s;
	}
	
}
