/************************************************************            }
 * Noncoding Significance Analysis of Hg19					*
 * 															*   
 * Author:		Felix Dietlein								*   
 *															*   
 * Copyright:	(C) 2021 									*   
 *															*   
 * License:		BSD-3-Clause open source license			*   
 *															*   
 * Summary: This script executes the significance analysis	*
 * 			for 10kb intervals based on the count- and 		*
 * 			clustering-based metrics described in the		*
 * 			methods. After completion, the script writes	*
 * 			the p-values to a file in the Significance		*
 * 			folder. The script can be run on 10kb intervals	*
 * 			with an offset (0kb, 2.5kb, 5kb or 75kb) which 	*
 * 			is provided as a parameter to this script.		*
  * 														*   
 ************************************************************/

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Hashtable;
import java.util.concurrent.ThreadLocalRandom;

import org.apache.commons.math3.distribution.BinomialDistribution;
import org.apache.commons.math3.distribution.ChiSquaredDistribution;
import org.apache.commons.math3.distribution.PoissonDistribution;
import org.apache.commons.math3.special.Gamma;

import Jama.Matrix;

public class CombinedStatistics_10 {
	static String separator="/"; //separator for file names (changes between Windows and Unix)
	static String entity_sel=""; //cancer type for which to perform the analysis
	static int shift_mut=10000; //offset parameters of the intervals (can be 0kb, 25kb, 50kb or 75kb)
	
	static String folder_auxiliary=separator;  //folder in which the intermediate files are localized
	static String subfolder_auxiliary=folder_auxiliary+entity_sel+"_10kb_"+shift_mut+separator; //output folder of the intermediate files generated by this method
	static String folder_significance=""; //output folder for the final significance file generated by this method
	static String folder_annotation="";	//Hg19 annotation folder (e.g. epigenomic data). Will be downloaded if it cannot be found
	static String folder_counts_all=""; //output folder which counts the number of mutations for each cancer type and is used for background calibration. Might be re-usable when running the method multiple times
	
	static String file_coverage=folder_annotation+"CoverageFiles"+separator+"Coverage_"+shift_mut+".txt"; //gnomAD coverage files to exclude regions of low coverage
	static String file_genome=folder_annotation+"Hg19"+separator+"chr"; //Reference genome
	static String file_exons=folder_annotation+"Hg19"+separator+"Exons_Hg19.txt"; //Annotation of Exonic regions
	static String file_as_annotation=folder_annotation+"ASAnnotationHg19"+separator+"ASAnnotation_chr"; //AS annotation for coding regions to identify destructive mutations
	static String file_exclude_regions_liver=folder_annotation+"ExcludeRegions"+separator+"ExcludeCTCF_Regions_Liver.txt"; //TAD boundary regions to exclude from the analysis, since they are hypermutated in some cancer types
	static String file_exclude_regions_non_liver=folder_annotation+"ExcludeRegions"+separator+"ExcludeCTCF_Regions_NonLiver.txt"; //TAD boundary regions to exclude from the analysis, since they are hypermutated in some cancer types
	static String file_dichotomous=folder_annotation+"Align36mer_Dichotomous"+separator+"Align36mer_"; //alignability of mutations based on their surrounding 36mer. if there are multiple possible possibilities for alignment, mutations can result from misalignment due to sequencing errors
	static String file_splice_ai=folder_annotation+"SNV_Raw_10"+separator; //annotation of splice sites				   
	static String file_epi_signal_1000=folder_annotation+"SummarizedSignal"+separator+"Signal1000_Chr"; //Epignenomic signal 1kb
	static String file_epi_signal_10000=folder_annotation+"SummarizedSignal"+separator+"Signal10000_Chr"; //Epignenomic signal 10kb
	
	static String file_splice_count=subfolder_auxiliary+"SpliceCount.txt"+SignificanceNoncoding.out_suffix; //output file of the number of splice site mutations per interval
	
	static String file_clumps_count_combi=subfolder_auxiliary+"ClumpsCountCombi.txt"+SignificanceNoncoding.out_suffix; //output file of the clustering score in each interval
	static String file_factor_clumps=subfolder_auxiliary+"FactorClumps.txt"+SignificanceNoncoding.out_suffix; //output files of the weights to normalize clustering scores to a uniform distribution
	static String file_max_factor=subfolder_auxiliary+"FactorMax.txt"+SignificanceNoncoding.out_suffix; //output files of the factors to model distribution variance of clustering scores depending on their average
	static String file_clumps_count_combi_indel=subfolder_auxiliary+"ClumpsCountCombiIndel.txt"+SignificanceNoncoding.out_suffix; //output file of the clustering score in each interval (indels only)
	static String file_factor_clumps_indel=subfolder_auxiliary+"FactorClumpsIndel.txt"+SignificanceNoncoding.out_suffix; //output files of the weights to normalize clustering scores to a uniform distribution (indels only)
	static String file_max_factor_indel=subfolder_auxiliary+"FactorMaxIndel.txt"+SignificanceNoncoding.out_suffix; //output files of the factors to model distribution variance of clustering scores depending on their average (indels only)
		
	static String file_count_indel1=subfolder_auxiliary+"CountIndel1.txt"+SignificanceNoncoding.out_suffix; //output file for indel counts (similarity-based model)
	static String file_count_indel2=subfolder_auxiliary+"CountIndel2.txt"+SignificanceNoncoding.out_suffix; //output file for indel counts (similarity-based model)
	static String file_count_combi1=subfolder_auxiliary+"CountCombi1.txt"+SignificanceNoncoding.out_suffix; //output file for mutation counts (similarity-based model)
	static String file_count_combi2=subfolder_auxiliary+"CountCombi2.txt"+SignificanceNoncoding.out_suffix; //output file for mutation counts (similarity-based model)
	static String file_p_indel=subfolder_auxiliary+"PIndel.txt"+SignificanceNoncoding.out_suffix;  //output file for count-based pvalues (epigenomic model, indels only)
	static String file_p_combi=subfolder_auxiliary+"PCombi.txt"+SignificanceNoncoding.out_suffix; //output file for count-based pvalues (epigenomic model)
	
	static String file_count_epigenomic_combi1=subfolder_auxiliary+"EpigenomicCombi1.txt"+SignificanceNoncoding.out_suffix; //output file for mutation counts (epigenomic model)
	static String file_count_epigenomic_combi2=subfolder_auxiliary+"EpigenomicCombi2.txt"+SignificanceNoncoding.out_suffix; //output file for mutation counts (epigenomic model)
	static String file_count_epigenomic_indel1=subfolder_auxiliary+"EpigenomicIndel1.txt"+SignificanceNoncoding.out_suffix; //output file for indel counts (epigenomic model)
	static String file_count_epigenomic_indel2=subfolder_auxiliary+"EpigenomicIndel2.txt"+SignificanceNoncoding.out_suffix; //output file for indel counts (epigenomic model)
	static String file_p_epigenomic_combi=subfolder_auxiliary+"PEpigenomiCombi.txt"+SignificanceNoncoding.out_suffix; //output file for count-based pvalues (epigenomic model)
	static String file_p_epigenomic_indel=subfolder_auxiliary+"PEpigenomiIndel.txt"+SignificanceNoncoding.out_suffix; //output file for count-based pvalues (epigenomic model, indels only)
	
	static String file_out_sign=folder_significance+"Significance_"+entity_sel+"_"+shift_mut+".txt"+SignificanceNoncoding.out_suffix; //output file of the combined significance that includes all p-values computed by this method
	
	static String[][] files_donors=null; //internal file: list of sample IDs per cancer types
	static String[][][] files_mut_snv=null; //internal file: separate files of SNV mutations per cancer types and chromosome
	static String[][][] files_mut_indel=null; //internal file: separate files of indel mutations per cancer types and chromosome
	
	static String file_n_indel_quality2=folder_counts_all+"n_indel_quality2_"+shift_mut+".txt"+SignificanceNoncoding.out_suffix;  //output file for indel counts of all cancer types (used for background calibration)
	static String file_n_quality2=folder_counts_all+"n_quality2_"+shift_mut+".txt"+SignificanceNoncoding.out_suffix; //output file for mutation counts of all cancer types (used for background calibration)

	//cancer types used for background calibration (this default setting can be changes by parsing an argument to the method)
	static String[] all_entities=new String[]{"Biliary","Bladder","Brain","Breast","Cervix","Colorectal","Endocrine","Endometrium","Esophagus","Gastric","HeadNeck","Kidney","Leukemia","Liver","Lung","Lymphoma","Myeloid","Ovary","Pancreas","Pleura","Prostate","Sarcoma","Skin","Thyroid"};
	
	
	static String[] chr={"1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","17","18","19","20","21","22","X","Y"}; //chromosomes
	static String[] chr2={"1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","17","18","19","20","21","22","23","24"}; //chromosomes, alternative annotation
	static int[] chr_length={ //length of chromosomes in Hg19
			249250621,
			243199373,
			198022430,
			191154276,
			180915260,
			171115067,
			159138663,
			146364022,
			141213431,
			135534747,
			135006516,
			133851895,
			115169878,
			107349540,
			102531392,
			90354753,
			81195210,
			78077248,
			59128983,
			63025520,
			48129895,
			51304566,
			155270560,
			59373566
		};
	
	static int[] mid_chr_length={ //position of centromers in Hg19
			124392026,
			93265016,
			91180819,
			50268375,
			48330884,
			60775596,
			59882946,
			45637528,
			48880833,
			40147542,
			53598333,
			35616825,
			17837559,
			17628963,
			19073787,
			36629359,
			24053864,
			17199665,
			26552105,
			27450164,
			13104106,
			14710791,
			60523211,
			12457255
		};
	
	static ArrayList<Mutation>[][] mutations=new ArrayList[chr.length][];  //mutations of the cancer type examined after reading and exluding low-quality mutations
	static double[][] alignability=new double[chr.length][]; //alignability of positions based on surrounding 36mer
	static double[][] alignability_fine=new double[chr.length][];  //alignability of positions based on surrounding 36mer
	static ArrayList<Integer>[][] exclude=null; //excluded subintervals based on CTCF 
	
	static ArrayList<int[]>[][] interval_align=new ArrayList[chr.length][]; //subintervals with sufficient alignability and not excluded (for simulation of positions in clustering-based metrics)
	
	static double[][] coverage=null; //coverage
	
	//intitiate paths and global variables based on the parameters parsed to the script from outside
	public static void initiate(String entity_selX, int shift_mutX, String folder_auxiliaryX, String folder_significanceX,String folder_annotationX,String folder_counts_allX, String[] all_entitiesX, String[][] files_donorsX, String[][][] files_mut_snvX, String[][][] files_mut_indelX){
		
		all_entities=all_entitiesX;
		entity_sel=entity_selX;
		shift_mut=shift_mutX;
		
		folder_auxiliary=folder_auxiliaryX;
		folder_significance=folder_significanceX;
		folder_annotation=folder_annotationX;	
		folder_counts_all=folder_counts_allX;
		
		subfolder_auxiliary=folder_auxiliary+entity_sel+"_10kb_"+shift_mut+separator;
		
		file_coverage=folder_annotation+"CoverageFiles"+separator+"Coverage_"+shift_mut+".txt";
		file_genome=folder_annotation+"Hg19"+separator+"chr";
		file_exons=folder_annotation+"Hg19"+separator+"Exons_Hg19.txt";
		file_as_annotation=folder_annotation+"ASAnnotationHg19"+separator+"ASAnnotation_chr";
		file_exclude_regions_liver=folder_annotation+"ExcludeRegions"+separator+"ExcludeCTCF_Regions_Liver.txt";
		file_exclude_regions_non_liver=folder_annotation+"ExcludeRegions"+separator+"ExcludeCTCF_Regions_NonLiver.txt";
		file_dichotomous=folder_annotation+"Align36mer_Dichotomous"+separator+"Align36mer_";
		file_splice_ai=folder_annotation+"SNV_Raw_10"+separator;				   
		file_epi_signal_1000=folder_annotation+"SummarizedSignal"+separator+"Signal1000_Chr";
		file_epi_signal_10000=folder_annotation+"SummarizedSignal"+separator+"Signal10000_Chr";
		
		file_splice_count=subfolder_auxiliary+"SpliceCount.txt"+SignificanceNoncoding.out_suffix;
		
		file_clumps_count_combi=subfolder_auxiliary+"ClumpsCountCombi.txt"+SignificanceNoncoding.out_suffix;
		file_factor_clumps=subfolder_auxiliary+"FactorClumps.txt"+SignificanceNoncoding.out_suffix;
		file_max_factor=subfolder_auxiliary+"FactorMax.txt"+SignificanceNoncoding.out_suffix;
		file_clumps_count_combi_indel=subfolder_auxiliary+"ClumpsCountCombiIndel.txt"+SignificanceNoncoding.out_suffix;
		file_factor_clumps_indel=subfolder_auxiliary+"FactorClumpsIndel.txt"+SignificanceNoncoding.out_suffix;
		file_max_factor_indel=subfolder_auxiliary+"FactorMaxIndel.txt"+SignificanceNoncoding.out_suffix;
			
		file_count_indel1=subfolder_auxiliary+"CountIndel1.txt"+SignificanceNoncoding.out_suffix;
		file_count_indel2=subfolder_auxiliary+"CountIndel2.txt"+SignificanceNoncoding.out_suffix;
		file_count_combi1=subfolder_auxiliary+"CountCombi1.txt"+SignificanceNoncoding.out_suffix;
		file_count_combi2=subfolder_auxiliary+"CountCombi2.txt"+SignificanceNoncoding.out_suffix;
		file_p_indel=subfolder_auxiliary+"PIndel.txt"+SignificanceNoncoding.out_suffix;
		file_p_combi=subfolder_auxiliary+"PCombi.txt"+SignificanceNoncoding.out_suffix;
		
		file_count_epigenomic_combi1=subfolder_auxiliary+"EpigenomicCombi1.txt"+SignificanceNoncoding.out_suffix;
		file_count_epigenomic_combi2=subfolder_auxiliary+"EpigenomicCombi2.txt"+SignificanceNoncoding.out_suffix;
		file_count_epigenomic_indel1=subfolder_auxiliary+"EpigenomicIndel1.txt"+SignificanceNoncoding.out_suffix;
		file_count_epigenomic_indel2=subfolder_auxiliary+"EpigenomicIndel2.txt"+SignificanceNoncoding.out_suffix;
		file_p_epigenomic_combi=subfolder_auxiliary+"PEpigenomiCombi.txt"+SignificanceNoncoding.out_suffix;
		file_p_epigenomic_indel=subfolder_auxiliary+"PEpigenomiIndel.txt"+SignificanceNoncoding.out_suffix;
		
		file_out_sign=folder_significance+"Significance_"+entity_sel+"_"+shift_mut+".txt"+SignificanceNoncoding.out_suffix;
		
		file_n_indel_quality2=folder_counts_all+"n_indel_quality2_"+shift_mut+".txt"+SignificanceNoncoding.out_suffix;
		file_n_quality2=folder_counts_all+"n_quality2_"+shift_mut+".txt"+SignificanceNoncoding.out_suffix;
		
		mutations=new ArrayList[chr.length][];
		alignability=new double[chr.length][];
		alignability_fine=new double[chr.length][];
		exclude=null;
		
		interval_align=new ArrayList[chr.length][];
		coverage=null;
		
		files_donors=files_donorsX;
		files_mut_snv=files_mut_snvX;
		files_mut_indel=files_mut_indelX;

	}
	
	//compute epigenome-based p-values. In addition to p-values the method returns the counts in each interval.
	//The method compares the observed number of mutations in each interval with the expected number of mutations based on the underlying epigenomic data.
	//It computes p-values for 1kb and 10kb intervals and summarizes p-values of neighboring 1kb and 10kb intervals using Tippett's method. 
	public static double[][][][] sign_epigenomic(double[][][] chromatin_1000, double[][][] chromatin_10000, int[][] count_1000, int[][] count_10000, double[][] coverage){//mutations,coverage
		double[][] p_1000=p_1000(chromatin_1000,count_1000,coverage);
		double[][] p_10000=p_10000(chromatin_10000,count_10000,coverage);
		double[][] alpha_gamma_1000=null;
		double[][] beta_gamma_1000=null;
		{
			double[][][] ab= alpha_beta_1000(chromatin_1000,count_1000,p_1000,coverage);
			alpha_gamma_1000=ab[0];
			beta_gamma_1000=ab[1];
		}
		double[][] alpha_gamma_10000=null;
		double[][] beta_gamma_10000=null;
		{
			double[][][] ab= alpha_beta_10000(chromatin_10000,count_10000,p_10000,coverage);
			alpha_gamma_10000=ab[0];
			beta_gamma_10000=ab[1];
		}
		
		SignCount sign_count_10000=sign_10000( chromatin_10000,  p_10000,  count_10000, alpha_gamma_10000, beta_gamma_10000,  coverage);
		SignCount sign_count_1000_min=sign_1000_min( chromatin_1000,  p_1000,  count_1000,  alpha_gamma_1000,  beta_gamma_1000,   coverage);
		
		double[][] sign_10000=sign_count_10000.sign;
		double[][] sign_1000_min=sign_count_1000_min.sign;
		double[][][] c_10000=sign_count_10000.count;
		double[][][] count_1000_min=sign_count_1000_min.count;
		
		
		
		double[][][] sign=new double[chr.length][][];
		for (int i=0;i<sign_10000.length;i++){
			sign[i]=new double[sign_10000[i].length][2];
			for (int j=0;j<sign_10000[i].length;j++){
				sign[i][j][0]=Math.max(0, sign_10000[i][j]);
				sign[i][j][1]=Math.max(0, sign_1000_min[i][j]);
				
			}
		}
		return new double[][][][] {sign, c_10000,count_1000_min};
	}
	
	//epigenomics based p-values for 10kb intervals
	public static SignCount sign_10000(double[][][] chromatin_10000, double[][] p_10000,  int[][] count_10000, double[][] alpha_gamma_10000, double[][] beta_gamma_10000,  double[][] coverage){//double[][]
				
		double[][] alpha_10000=new double[chr.length][]; 
		double[][] beta_10000=new double[chr.length][]; 
		for (int i=0;i<chr.length;i++){
			alpha_10000[i]=new double[1+(chr_length[i]-shift_mut)/10000];
			beta_10000[i]=new double[1+(chr_length[i]-shift_mut)/10000];
		}
		
		ArrayList<double[]> xx_10000=new ArrayList<double[]>();
		for (int i=0;i<chromatin_10000.length;i++){
			for (int j=0;j<chromatin_10000[i].length;j++){
				if(low(chr[i])<=coverage[i][j]&&coverage[i][j]<=high(chr[i])){
					int k_max=-1;
					double max=-Double.MAX_VALUE;
					for (int k=0;k<chromatin_10000[i][j].length;k++){
						int z=(int)(100*(chromatin_10000[i][j][k]+4)/14.0);
						if(z<0){
							z=0;
						}
						if(z>99){
							z=99;
						}
						if(p_10000[k][z]>max){
							max=p_10000[k][z];
							k_max=k;
						}
					}
					
						int z=(int)(100*(chromatin_10000[i][j][k_max]+4)/14.0);
						if(z<0){
							z=0;
						}
						if(z>99){
							z=99;
						}
						int zz=(int)(10*p_10000[k_max][z]);
						if(zz>9){
							zz=9;
						}
						
						double p1=1;
						double p2=1;
						if(count_10000[i][j]>0){
							p1=1-cum_gamma_poisson(count_10000[i][j]-1,alpha_gamma_10000[k_max][zz],beta_gamma_10000[k_max][zz]);
							if(count_10000[i][j]>1){
								p2=1-cum_gamma_poisson(count_10000[i][j]-2,alpha_gamma_10000[k_max][zz],beta_gamma_10000[k_max][zz]);
							}
						}
						
						double p=(p2-p1)*Math.random()+p1;
						alpha_10000[i][j]=alpha_gamma_10000[k_max][zz];
						beta_10000[i][j]=beta_gamma_10000[k_max][zz];
						if(k_max==0&&z==0){
							alpha_10000[i][j]=0;
							beta_10000[i][j]=0;
							p=1;
						}
						xx_10000.add(new double[]{p,i,j});
					
				}
				
			}
		}
		double[][] ssum_10000=new double[chr.length][];
		double[][] ssum2_10000=new double[chr.length][];
		boolean[][] skip_10000=new boolean[chr.length][];
		for (int i=0;i<chr.length;i++){
			ssum_10000[i]=new double[count_10000[i].length];
			ssum2_10000[i]=new double[count_10000[i].length];
			skip_10000[i]=new boolean[count_10000[i].length];
		}
		
		Comparator<double[]> comp=(double[] aa, double[] bb)->{
			return new Double(aa[0]).compareTo(bb[0]);
		};
		
		Collections.sort(xx_10000,comp);
		for (int i=0;i<(int)(xx_10000.size()*0.01);i++){
			skip_10000[(int)(xx_10000.get(i)[1])][(int)(xx_10000.get(i)[2])]=true;
		}
		
		ArrayList<Double> ww_10000=new ArrayList<Double>();
		for (int kk=1;kk<=15;kk++){
			if(ww_10000.size()>0){
				for (int i=0;i<count_10000.length;i++){
					for (int j=0;j<count_10000[i].length;j++){
						if(j-ww_10000.size()>=0&&low(chr[i])<=coverage[i][(j-ww_10000.size())]&&coverage[i][(j-ww_10000.size())]<high(chr[i])){
							ssum_10000[i][j]+=ww_10000.get(ww_10000.size()-1)*count_10000[i][j-ww_10000.size()];
							ssum2_10000[i][j]+=ww_10000.get(ww_10000.size()-1);
						}	
						if(j+ww_10000.size()<coverage[i].length&&low(chr[i])<=coverage[i][(j+ww_10000.size())]&&coverage[i][(j+ww_10000.size())]<high(chr[i])){
							ssum_10000[i][j]+=ww_10000.get(ww_10000.size()-1)*count_10000[i][j+ww_10000.size()];
							ssum2_10000[i][j]+=ww_10000.get(ww_10000.size()-1);
						}	
						
						
					}
				}
			}
			
			
			Subthread_10000[] threads=new Subthread_10000[101];
			for (int i=0;i<threads.length;i++){
				threads[i]=new Subthread_10000();
				
				threads[i].ssum=ssum_10000;
				threads[i].ssum2=ssum2_10000;
				threads[i].coverage=coverage;
				threads[i].count=count_10000;
				threads[i].skip=skip_10000;
				threads[i].alpha=alpha_10000;
				threads[i].beta=beta_10000;
				threads[i].kk=kk;
				threads[i].w=(double)(i)/100.0;
				
			}
			execute(threads,30);
			
			double max=-Double.MAX_VALUE;
			double w_max=-1;
			for (int i=0;i<threads.length;i++){
				//System.out.println(kk+"	"+threads[i].w+"	"+threads[i].sum2);
				if(threads[i].sum2>max){
					max=threads[i].sum2;
					w_max=threads[i].w;
				}
			}
			ww_10000.add(w_max);
			System.out.println(kk+"	"+max+"	"+w_max);
			
			
		}	
		
		for (int j=ww_10000.size()-1;j>=0;j--){
			if(ww_10000.get(j)>0){
				break;
			}
			ww_10000.remove(j);
		}
		
		
		double[][][] c_10000=new double[chr.length][][];
		for (int i=0;i<chr.length;i++){
			c_10000[i]=new double[1+(chr_length[i]-shift_mut)/10000][3];
		}
		double[][] sign_10000=new double[chr.length][];
		for (int i=0;i<chr.length;i++){
			sign_10000[i]=new double[1+(chr_length[i]-shift_mut)/10000];
			for (int j=0;j<sign_10000[i].length;j++){
				sign_10000[i][j]=1;
			}
		}
		for (int i=0;i<count_10000.length;i++){
			for (int j=0;j<count_10000[i].length;j++){
				if(low(chr[i])<=coverage[i][j]&&coverage[i][j]<high(chr[i])){
					if(!Double.isNaN(alpha_10000[i][j])&&!Double.isNaN(beta_10000[i][j])&&alpha_10000[i][j]!=0&&beta_10000[i][j]!=0){
						
		//				alignabiity & mappability
						
						double sum1=0;
						double sum2=0;
						for (int k=1;k<=ww_10000.size();k++){
							if(j-k>=0&&low(chr[i])<=coverage[i][(j-k)]&&coverage[i][(j-k)]<high(chr[i])&&alignability[i][j-k]>0.5){
								sum1+=ww_10000.get(k-1)*count_10000[i][j-k]/alignability[i][j-k];
								sum2+=ww_10000.get(k-1);
							}	
							if(j+k<coverage[i].length&&low(chr[i])<=coverage[i][(j+k)]&&coverage[i][(j+k)]<high(chr[i])&&alignability[i][j+k]>0.5){
								sum1+=ww_10000.get(k-1)*count_10000[i][j+k]/alignability[i][j+k];
								sum2+=ww_10000.get(k-1);
							}
						}
						
						
						c_10000[i][j]=new double[]{count_10000[i][j],alpha_10000[i][j]+sum1,beta_10000[i][j]+sum2};
						
						double p1=1;
						double p2=1;
						if(count_10000[i][j]>0){
							p1=1-cum_gamma_poisson(count_10000[i][j]-1,alpha_10000[i][j]+sum1,beta_10000[i][j]+sum2);
							if(count_10000[i][j]>1){
								p2=1-cum_gamma_poisson(count_10000[i][j]-2,alpha_10000[i][j]+sum1,beta_10000[i][j]+sum2);
							}
						}
						
						sign_10000[i][j]=(p2-p1)*Math.random()+p1;
						if(Double.isNaN(sign_10000[i][j])){
							sign_10000[i][j]=1;
						}
					}
					else{
						sign_10000[i][j]=1.0;
					}
				}
				
			}
		}
		return new SignCount(sign_10000,c_10000);
	}
	
	//Object to return significance and count values together
	private static class SignCount{
		double[][] sign=null;
		double[][][] count=null;
		public SignCount(double[][] sign, double[][][] count){
			this.sign=sign;
			this.count=count;
		}
	}
	
	//epigenomics based p-values for neighboring 1kb intervals, which are then summarized using Tippett's method
	public static SignCount sign_1000_min(double[][][] chromatin_1000, double[][] p_1000,  int[][] count_1000, double[][] alpha_gamma_1000, double[][] beta_gamma_1000,  double[][] coverage){//double[][]
		double[][] alpha_1000=new double[chr.length][]; 
		double[][] beta_1000=new double[chr.length][]; 
		for (int i=0;i<chr.length;i++){
			alpha_1000[i]=new double[1+(chr_length[i]-shift_mut)/1000];
			beta_1000[i]=new double[1+(chr_length[i]-shift_mut)/1000];
		}
		
		ArrayList<double[]> xx_1000=new ArrayList<double[]>();
		for (int i=0;i<chromatin_1000.length;i++){
			for (int j=0;j<chromatin_1000[i].length;j++){
				if(low(chr[i])<=coverage[i][j/10]&&coverage[i][j/10]<=high(chr[i])){
					int k_max=-1;
					double max=-Double.MAX_VALUE;
					for (int k=0;k<chromatin_1000[i][j].length;k++){
						int z=(int)(100*(chromatin_1000[i][j][k]+4)/14.0);
						if(z<0){
							z=0;
						}
						if(z>99){
							z=99;
						}
						if(p_1000[k][z]>max){
							max=p_1000[k][z];
							k_max=k;
						}
					}
					
					int z=(int)(100*(chromatin_1000[i][j][k_max]+4)/14.0);
					if(z<0){
						z=0;
					}
					if(z>99){
						z=99;
					}
					int zz=(int)(10*p_1000[k_max][z]);
					if(zz>9){
						zz=9;
				
					}
						
					double p1=1;
					double p2=1;
					if(count_1000[i][j]>0){
						p1=1-cum_gamma_poisson(count_1000[i][j]-1,alpha_gamma_1000[k_max][zz],beta_gamma_1000[k_max][zz]);
						if(count_1000[i][j]>1){
							p2=1-cum_gamma_poisson(count_1000[i][j]-2,alpha_gamma_1000[k_max][zz],beta_gamma_1000[k_max][zz]);
						}
					}
					double p=(p2-p1)*Math.random()+p1;
					alpha_1000[i][j]=alpha_gamma_1000[k_max][zz];
					beta_1000[i][j]=beta_gamma_1000[k_max][zz];
					
					if(k_max==0&&z==0){
						alpha_1000[i][j]=0;
						beta_1000[i][j]=0;
						p=1;
					}
					xx_1000.add(new double[]{p,i,j});
				}
				
			}
		}
		
		double[][] ssum_1000=new double[chr.length][];
		double[][] ssum2_1000=new double[chr.length][];
		boolean[][] skip_1000=new boolean[chr.length][];
		for (int i=0;i<chr.length;i++){
			ssum_1000[i]=new double[count_1000[i].length];
			ssum2_1000[i]=new double[count_1000[i].length];
			skip_1000[i]=new boolean[count_1000[i].length];
		}
		
		Comparator<double[]> comp=(double[] aa, double[] bb)->{
			return new Double(aa[0]).compareTo(bb[0]);
		};
		
		Collections.sort(xx_1000,comp);
		for (int i=0;i<(int)(xx_1000.size()*0.01);i++){
			skip_1000[(int)(xx_1000.get(i)[1])][(int)(xx_1000.get(i)[2])]=true;
		}
		
		ArrayList<Double> ww_1000=new ArrayList<Double>();
		for (int kk=1;kk<=15;kk++){
			if(ww_1000.size()>0){
				for (int i=0;i<count_1000.length;i++){
					for (int j=0;j<count_1000[i].length;j++){
						for (int k=0;k<10;k++){
							if(j-10*ww_1000.size()-k+9>=0&&low(chr[i])<=coverage[i][(j-10*ww_1000.size()-k+9)*1000/10000]&&coverage[i][(j-10*ww_1000.size()-k+9)*1000/10000]<high(chr[i])){
								ssum_1000[i][j]+=ww_1000.get(ww_1000.size()-1)*count_1000[i][j-10*ww_1000.size()-k+9];
								ssum2_1000[i][j]+=ww_1000.get(ww_1000.size()-1);
							}	
							if(j+10*ww_1000.size()+k-9<coverage[i].length&&low(chr[i])<=coverage[i][(j+10*ww_1000.size()+k-9)*1000/10000]&&coverage[i][(j+10*ww_1000.size()+k-9)*1000/10000]<high(chr[i])){
								ssum_1000[i][j]+=ww_1000.get(ww_1000.size()-1)*count_1000[i][j+10*ww_1000.size()+k-9];
								ssum2_1000[i][j]+=ww_1000.get(ww_1000.size()-1);
							}
						}
						
					}
				}
			}
			
			
			
			Subthread_1000[] threads=new Subthread_1000[101];
			for (int i=0;i<threads.length;i++){
				threads[i]=new Subthread_1000();
				
				threads[i].ssum=ssum_1000;
				threads[i].ssum2=ssum2_1000;
				threads[i].coverage=coverage;
				threads[i].count=count_1000;
				threads[i].skip=skip_1000;
				threads[i].alpha=alpha_1000;
				threads[i].beta=beta_1000;
				threads[i].kk=kk;
				threads[i].w=(double)(i)/100.0;
				
			}
			execute(threads,30);
			
			double max=-Double.MAX_VALUE;
			double w_max=-1;
			for (int i=0;i<threads.length;i++){
				if(threads[i].sum2>max){
					max=threads[i].sum2;
					w_max=threads[i].w;
				}
			}
			ww_1000.add(w_max);
			System.out.println(kk+"	"+max+"	"+w_max);
			
			
		}	
		
		for (int j=ww_1000.size()-1;j>=0;j--){
			if(ww_1000.get(j)>0){
				break;
			}
			ww_1000.remove(j);
		}
		
		
		
		double[][][] c_1000=new double[chr.length][][];
		for (int i=0;i<chr.length;i++){
			c_1000[i]=new double[1+(chr_length[i]-shift_mut)/1000][3];
		}
		double[][] sign_1000=new double[chr.length][];
		for (int i=0;i<chr.length;i++){
			sign_1000[i]=new double[1+(chr_length[i]-shift_mut)/1000];
			for (int j=0;j<sign_1000[i].length;j++){
				sign_1000[i][j]=1;
			}
		}
		for (int i=0;i<count_1000.length;i++){
			for (int j=0;j<count_1000[i].length;j++){
				if(low(chr[i])<=coverage[i][j/10]&&coverage[i][j/10]<high(chr[i])){
					if(!Double.isNaN(alpha_1000[i][j])&&!Double.isNaN(beta_1000[i][j])&&alpha_1000[i][j]!=0&&beta_1000[i][j]!=0){
					
			//			alignability & mappability
						
						double sum1=0;
						double sum2=0;
						for (int k=1;k<=ww_1000.size();k++){
							for (int kk=0;kk<10;kk++){
								if(j-10*k-kk+9>=0&&low(chr[i])<=coverage[i][(j-10*k-kk+9)*1000/10000]&&coverage[i][(j-10*k-kk+9)*1000/10000]<high(chr[i])&&alignability_fine[i][j-10*k-kk+9]>0.5){
									sum1+=ww_1000.get(k-1)*count_1000[i][j-10*k-kk+9]/alignability_fine[i][j-10*k-kk+9];
									sum2+=ww_1000.get(k-1);
								}	
								if(j+10*k+kk-9<coverage[i].length&&low(chr[i])<=coverage[i][(j+10*k+kk-9)*1000/10000]&&coverage[i][(j+10*k+kk-9)*1000/10000]<high(chr[i])&&alignability_fine[i][j+10*k+kk-9]>0.5){
									sum1+=ww_1000.get(k-1)*count_1000[i][j+10*k+kk-9]/alignability_fine[i][j+10*k+kk-9];
									sum2+=ww_1000.get(k-1);
								}
							}
							
						}
						
						c_1000[i][j]=new double[]{count_1000[i][j],alpha_1000[i][j]+sum1,beta_1000[i][j]+sum2};
						
						
						double p1=1;
						double p2=1;
						if(count_1000[i][j]>0){
							p1=1-cum_gamma_poisson(count_1000[i][j]-1,alpha_1000[i][j]+sum1,beta_1000[i][j]+sum2);
							if(count_1000[i][j]>1){
								p2= 1-cum_gamma_poisson(count_1000[i][j]-2,alpha_1000[i][j]+sum1,beta_1000[i][j]+sum2);
							}
						}
						
						sign_1000[i][j]=(p2-p1)*Math.random()+p1;
						if(Double.isNaN(sign_1000[i][j])){
							sign_1000[i][j]=1;
						}
					}
					else{
						sign_1000[i][j]=1.0;
					}
				}
				
			}
		}
		
		double[][] p_min=new double [chr.length][];
		for (int i=0;i<p_min.length;i++){
			p_min[i]=new double[1+(chr_length[i]-shift_mut)/10000];
			for (int j=0;j<p_min[i].length;j++){
				p_min[i][j]=1;
			}
		}

		int size = 10;
		double effSize;
		{
			MVNEstimator est = new MVNEstimator(size);
			double[] z = new double[size];
		for (int i=0;i<chr.length;i++){
			for (int j=0;j<1+(chr_length[i]-shift_mut)/10000;j++){
				if(low(chr[i])<=coverage[i][j]&&coverage[i][j]<high(chr[i])){
					for (int k=0;k<size;k++){
						if(j*size+k<sign_1000[i].length){
							z[k]=( sign_1000[i][j*size+k] );
						}
						else{
							z[k]=0.5;
						}
					}
					est.update(z);
				}
			}
		}
			effSize = est.effSize();
		}

		for (int i=0;i<chr.length;i++){
			for (int j=0;j<1+(chr_length[i]-shift_mut)/10000;j++){
				if(low(chr[i])<=coverage[i][j]&&coverage[i][j]<high(chr[i])){
					double min=1;
					for (int k=0;k<size;k++){
						if(j*size+k<sign_1000[i].length&&sign_1000[i][j*size+k]<min){
							min=sign_1000[i][j*size+k];
						}
					}
					if(Double.isNaN(min)){
						min=1;
					}
					else if(min>0){
						min=min;
					}
					else{
						min=0;
					}
					
					p_min[i][j]=(1-Math.pow(1-min,effSize));
				
				}
				
			}
		}
		return new SignCount(p_min,c_1000);
	}

	//remove samples with a high fraction of mutations in MSI-related contexts
	public static void remove_bad_msi_samples(){
		ArrayList<String> donors=new ArrayList<String>();
		Hashtable<String,Integer> table=new Hashtable<String,Integer>();
		ArrayList<int[]> counts_bad=new ArrayList<int[]>();
		ArrayList<int[]> counts_msi=new ArrayList<int[]>();
		
		for (int i=0;i<mutations.length;i++){
			for (int j=0;j<mutations[i].length;j++){
				if(low(chr[i])<=coverage[i][j]&&coverage[i][j]<high(chr[i])){
					for (int k=0;k<mutations[i][j].size();k++){
						Integer ii=table.get(mutations[i][j].get(k).donor);
						if(ii==null){
							ii=donors.size();
							table.put(mutations[i][j].get(k).donor, ii);
							donors.add(mutations[i][j].get(k).donor);
							counts_bad.add(new int[]{0,0});
							counts_msi.add(new int[]{0,0});
						}
						counts_bad.get(ii)[0]++;
						if(mutations[i][j].get(k).group>=1){//>=2
							counts_bad.get(ii)[1]++;
						}
						counts_msi.get(ii)[0]++;
						if(mutations[i][j].get(k).msi){
							counts_msi.get(ii)[1]++;
						}

					}
				}
			}
		}
		
		Hashtable<String,Integer> table_bad_donors=new Hashtable<String,Integer>();
		ArrayList<String> bad_donors=new ArrayList<String>();
		for (int i=0;i<donors.size();i++){
			if((double)(counts_bad.get(i)[1])/(double)(counts_bad.get(i)[0])>0.25){
				table_bad_donors.put(donors.get(i),bad_donors.size());
				bad_donors.add(donors.get(i));
			}
		}
		
		Hashtable<String,Integer> table_msi_donors=new Hashtable<String,Integer>();
		ArrayList<String> msi_donors=new ArrayList<String>();
		for (int i=0;i<donors.size();i++){
			if((double)(counts_msi.get(i)[1])/(double)(counts_msi.get(i)[0])>0.2){
				table_msi_donors.put(donors.get(i),msi_donors.size());
				msi_donors.add(donors.get(i));
			}
		}
		
		
		for (int i=0;i<mutations.length;i++){
			for (int j=0;j<mutations[i].length;j++){
				for (int k=mutations[i][j].size()-1;k>=0;k--){
					if(table_bad_donors.get(mutations[i][j].get(k).donor)!=null||table_msi_donors.get(mutations[i][j].get(k).donor)!=null||mutations[i][j].get(k).msi||mutations[i][j].get(k).msi2){
						mutations[i][j].remove(k);
					}
				}
			}
		}
		
	}
	
	//Subthread to optimize the factor for the hotspot-based p-value
	private static class SubthreadMaxCountFactor extends Thread{
		int[][] n=null;
		int[][] max=null;
		double[][] coverage=new double[0][];
		double f=-1;
		double sum=0;
		int status=0;
		
		public void run(){
			status=1;
			double sum_n=0;
			for (int i=0;i<n.length;i++){
				if(i!=0){
					continue;
				}
				for (int j=0;j<n[i].length;j++){
					if(low(chr[i])<=coverage[i][j]&&coverage[i][j]<=high(chr[i])){
						double eligible=10000.0*alignability[i][j];
						if(max[i][j]>0&&alignability[i][j]>0.05){
							double p=Math.pow(new PoissonDistribution(n[i][j]/eligible).cumulativeProbability(max[i][j]),eligible-1)*new PoissonDistribution(n[i][j]*f/eligible).cumulativeProbability(max[i][j])-Math.pow(new PoissonDistribution(n[i][j]/eligible).cumulativeProbability(max[i][j]-1),eligible-1)*new PoissonDistribution(n[i][j]*f/eligible).cumulativeProbability(max[i][j]-1);
							if(p>0){
								sum+=Math.log(p);
								sum_n++;
							}
							
						}
					}
				}
			}
			sum/=sum_n;
			status=2;
		}
	}
	
	//execute multiple Threads in parallel
	public static void execute(SubthreadMaxCountFactor[] threads, int no_cpu){
		boolean all_done=false;
		while(!all_done){
			all_done=true;
			int n1=0;
			int n2=0;		
			for (int i=0;i<threads.length;i++){
				if(threads[i].status==0){
					n1++;
				}
				if(threads[i].status==1){
					n2++;
				}
				if(threads[i].status!=2){
					all_done=false;
				}
			}
			if(n1>0&&n2<no_cpu){
				for (int i=0;i<threads.length;i++){
					if(threads[i].status==0){
						threads[i].status=1;
						threads[i].start();
						n1--;
						n2++;
						if(n1==0||n2>=no_cpu){
							break;
						}
					}
				}
			}
			try{
				Thread.sleep(10);
			}
			catch(java.lang.InterruptedException e){
			}
		}
	}
	
	//execute multiple Threads in parallel
	public static void execute(Subthread_1000[] threads, int no_cpu){
		boolean all_done=false;
		while(!all_done){
			all_done=true;
			int n1=0;
			int n2=0;		
			for (int i=0;i<threads.length;i++){
				if(threads[i].status==0){
					n1++;
				}
				if(threads[i].status==1){
					n2++;
				}
				if(threads[i].status!=2){
					all_done=false;
				}
			}
			if(n1>0&&n2<no_cpu){
				for (int i=0;i<threads.length;i++){
					if(threads[i].status==0){
						threads[i].status=1;
						threads[i].start();
						n1--;
						n2++;
						if(n1==0||n2>=no_cpu){
							break;
						}
					}
				}
			}
			try{
				Thread.sleep(10);
			}
			catch(java.lang.InterruptedException e){
			}
		}
	}
	
	//execute multiple Threads in parallel
	public static void execute(Subthread_10000[] threads, int no_cpu){
		boolean all_done=false;
		while(!all_done){
			all_done=true;
			int n1=0;
			int n2=0;		
			for (int i=0;i<threads.length;i++){
				if(threads[i].status==0){
					n1++;
				}
				if(threads[i].status==1){
					n2++;
				}
				if(threads[i].status!=2){
					all_done=false;
				}
			}
			if(n1>0&&n2<no_cpu){
				for (int i=0;i<threads.length;i++){
					if(threads[i].status==0){
						threads[i].status=1;
						threads[i].start();
						n1--;
						n2++;
						if(n1==0||n2>=no_cpu){
							break;
						}
					}
				}
			}
			try{
				Thread.sleep(10);
			}
			catch(java.lang.InterruptedException e){
			}
		}
	}
	
	//Subthread to annotate MSI status to each mutation
	private static class Subthread_MSI extends ThreadEx{
		int chr_index=-1;
		int status=0;
		ArrayList<Mutation>[][] mutations=null;
		public void runEx() throws java.io.IOException {
			status=1;
			ArrayList<char[]> genome=read_genome(chr[chr_index]);
			
			for (int i=0;i<mutations[chr_index].length;i++){
				for(int j=0;j<mutations[chr_index][i].size();j++){
					mutations[chr_index][i].get(j).msi=is_msi1(mutations[chr_index][i].get(j),genome);
					mutations[chr_index][i].get(j).msi2=is_msi2(mutations[chr_index][i].get(j),genome);
				}
			}
			status=2;
		}
	}
	
	//Subthread to annotate MSI status to each mutation (multiple cancer types)
	private static class Subthread_MSI_Multiple extends ThreadEx{
		int chr_index=-1;
		int status=0;
		ArrayList<Mutation>[][][] mutations=null;
		public void runEx() throws java.io.IOException {
			status=1;
			ArrayList<char[]> genome=read_genome(chr[chr_index]);
			for (int a=0;a<mutations.length;a++){
				for (int i=0;i<mutations[a][chr_index].length;i++){
					for(int j=0;j<mutations[a][chr_index][i].size();j++){
						mutations[a][chr_index][i].get(j).msi=is_msi1(mutations[a][chr_index][i].get(j),genome);
						mutations[a][chr_index][i].get(j).msi2=is_msi2(mutations[a][chr_index][i].get(j),genome);
					}
				}
			}
			
			status=2;
		}
	}
	
	//Thread to compute count-based p-values for 1kb intervals based on a Gamma-Poisson distribution 
	//alpha/beta parameters of Gamma-Poisson are parsed as an argument for each interval
	private static class Subthread_1000 extends Thread{
		double[][] ssum=new double[chr.length][];
		double[][] ssum2=new double[chr.length][];
		double[][] coverage=new double[0][];
		int[][] count=new int[0][];
		boolean[][] skip=new boolean[0][];
		double[][] alpha=new double[0][];
		double[][] beta=new double[0][];
		int kk=-1;
		double w=0;
		
		double sum2=0;
		volatile int status=0;
		
		public void run(){
			status=1;
			for (int i=0;i<count.length;i++){
				if(i!=0){
					continue;		
				}
				for (int j=0;j<count[i].length;j++){
					//System.out.println("AB	"+alpha[i][j]+"	"+beta[i][j]);
					if(low(chr[i])<=coverage[i][j*1000/10000]&&coverage[i][j*1000/10000]<high(chr[i])&&!Double.isNaN(alpha[i][j])&&!Double.isNaN(beta[i][j])&&alpha[i][j]!=0&&beta[i][j]!=0){
						double a=0;
						double b=0;
						for (int k=0;k<10;k++){
							if(j-10*kk-k+9>=0&&(j+10*kk+k-9)*1000/10000<coverage[i].length&&low(chr[i])<=coverage[i][(j-10*kk-k+9)*1000/10000]&&coverage[i][(j-10*kk-k+9)*1000/10000]<high(chr[i])&&low(chr[i])<=coverage[i][(j+10*kk+k-9)*1000/10000]&&coverage[i][(j+10*kk+k-9)*1000/10000]<high(chr[i])){
								a+=+w*count[i][j-10*kk-k+9]+w*count[i][j+10*kk+k-9];
								b+=2*w;
							}
						}
						if(!skip[i][j]){
							double pp=log_gamma_poisson_ab((int)(count[i][j]),alpha[i][j]+a+ssum[i][j],beta[i][j]+b+ssum2[i][j]);
							if(!Double.isNaN(pp)){
								sum2+=pp;
							}
								
						}
					}
				}
			}
			status=2;
		}
		
	}
	
	//Thread to compute count-based p-values for 10kb intervals based on a Gamma-Poisson distribution 
	//alpha/beta parameters of Gamma-Poisson are parsed as an argument for each interval
	private static class Subthread_10000 extends Thread{
		double[][] ssum=new double[chr.length][];
		double[][] ssum2=new double[chr.length][];
		double[][] coverage=new double[0][];
		int[][] count=new int[0][];
		boolean[][] skip=new boolean[0][];
		double[][] alpha=new double[0][];
		double[][] beta=new double[0][];
		int kk=-1;
		double w=0;
		
		double sum2=0;
		volatile int status=0;
		
		public void run(){
			status=1;
			for (int i=0;i<count.length;i++){
				if(i!=0){
					continue;		
				}
				for (int j=0;j<count[i].length;j++){
					//System.out.println("AB	"+alpha[i][j]+"	"+beta[i][j]);
					if(low(chr[i])<=coverage[i][j]&&coverage[i][j]<high(chr[i])&&!Double.isNaN(alpha[i][j])&&!Double.isNaN(beta[i][j])&&alpha[i][j]!=0&&beta[i][j]!=0){
						double a=0;
						double b=0;
						if(j-kk>=0&&(j+kk)<coverage[i].length&&low(chr[i])<=coverage[i][(j-kk)]&&coverage[i][(j-kk)]<high(chr[i])&&low(chr[i])<=coverage[i][(j+kk)]&&coverage[i][(j+kk)]<high(chr[i])){
							a+=+w*count[i][j-kk]+w*count[i][j+kk];
							b+=2*w;
						}
							
						if(!skip[i][j]){
							double pp=log_gamma_poisson_ab((int)(count[i][j]),alpha[i][j]+a+ssum[i][j],beta[i][j]+b+ssum2[i][j]);
							if(!Double.isNaN(pp)){
								sum2+=pp;
							}
								
						}
					}
				}
			}
			status=2;
		}
		
	}
	
	//Compute alpha beta parameters of a Gamma poisson distribution for each 1kb interval based on its underlying epigenomics data
	public static double[][][] alpha_beta_1000(double[][][] chromatin_1000, int[][] count_1000, double[][] p_1000, double[][] coverage){
		int[][][] histo_1000=new int[4][10][500];
		for (int i=0;i<chromatin_1000.length;i++){
			for (int j=0;j<chromatin_1000[i].length;j++){
				if(low(chr[i])<=coverage[i][j/10]&&coverage[i][j/10]<=high(chr[i])){
					int k_max=-1;
					double max=-Double.MAX_VALUE;
					for (int k=0;k<chromatin_1000[i][j].length;k++){
						int z=(int)(100*(chromatin_1000[i][j][k]+4)/14.0);
						if(z<0){
							z=0;
						}
						if(z>99){
							z=99;
						}
						if(p_1000[k][z]>max){
							max=p_1000[k][z];
							k_max=k;
						}
					}
					
					if(chromatin_1000[i][j][k_max]>-4){
						int z=(int)(100*(chromatin_1000[i][j][k_max]+4)/14.0);
						if(z<0){
							z=0;
						}
						if(z>99){
							z=99;
						}
						int zz=(int)(10*p_1000[k_max][z]);
						if(zz>9){
							zz=9;
						}
						
						
						histo_1000[k_max][zz] = histo_push( histo_1000[k_max][zz], count_1000[i][j] );
					}
					
					
				}
				
			}
		}
		
		double[][] alpha_gamma_1000=new double[4][10];//[][][chr.length][2]
		double[][] beta_gamma_1000=new double[4][10];//[][][chr.length][2]
				for (int i=0;i<histo_1000.length;i++){//[a][b]
					for (int j=0;j<histo_1000[i].length;j++){//[a][b]
						double r_avg=0;
						double r_n=0;
						for (int k=0;k<histo_1000[i][j].length;k++){
							r_avg+=k*histo_1000[i][j][k];
							r_n+=histo_1000[i][j][k];
						}
						r_avg/=r_n;
						double r_var=0;
						for (int k=0;k<histo_1000[i][j].length;k++){
							r_var+=(k-r_avg)*(k-r_avg)*histo_1000[i][j][k];
						}
						r_var/=r_n;
						
						alpha_gamma_1000[i][j]=r_avg*r_avg/(r_var-r_avg);
						beta_gamma_1000[i][j]=r_avg/(r_var-r_avg);
						
						
					}
				}
		
		return new double[][][] {alpha_gamma_1000,beta_gamma_1000};
	}
	
	//Compute alpha beta parameters of a Gamma poisson distribution for each 10kb interval based on its underlying epigenomics data
	public static double[][][] alpha_beta_10000(double[][][] chromatin_10000, int[][] count_10000, double[][] p_10000, double[][] coverage){
		int[][][] histo_10000=new int[4][10][500];
		for (int i=0;i<chromatin_10000.length;i++){
			for (int j=0;j<chromatin_10000[i].length;j++){
				if(low(chr[i])<=coverage[i][j]&&coverage[i][j]<=high(chr[i])){
					int k_max=-1;
					double max=-Double.MAX_VALUE;
					for (int k=0;k<chromatin_10000[i][j].length;k++){
						int z=(int)(100*(chromatin_10000[i][j][k]+4)/14.0);
						if(z<0){
							z=0;
						}
						if(z>99){
							z=99;
						}
						if(p_10000[k][z]>max){
							max=p_10000[k][z];
							k_max=k;
						}
					}
					
					if(chromatin_10000[i][j][k_max]>-4){
						int z=(int)(100*(chromatin_10000[i][j][k_max]+4)/14.0);
						if(z<0){
							z=0;
						}
						if(z>99){
							z=99;
						}
						int zz=(int)(10*p_10000[k_max][z]);
						if(zz>9){
							zz=9;
						}
						
						histo_10000[k_max][zz] = histo_push( histo_10000[k_max][zz], count_10000[i][j] );
					}
					
					
				}
				
			}
		}
		
		double[][] alpha_gamma_10000=new double[4][10];
		double[][] beta_gamma_10000=new double[4][10];
		for (int i=0;i<histo_10000.length;i++){
			for (int j=0;j<histo_10000[i].length;j++){
				double r_avg=0;
				double r_n=0;
				for (int k=0;k<histo_10000[i][j].length;k++){
					r_avg+=k*histo_10000[i][j][k];
					r_n+=histo_10000[i][j][k];
				}
				r_avg/=r_n;
				double r_var=0;
				for (int k=0;k<histo_10000[i][j].length;k++){
					r_var+=(k-r_avg)*(k-r_avg)*histo_10000[i][j][k];
				}
				r_var/=r_n;
				
				alpha_gamma_10000[i][j]=r_avg*r_avg/(r_var-r_avg);
				beta_gamma_10000[i][j]=r_avg/(r_var-r_avg);
				
				
			}
		}
		
		return new double[][][] {alpha_gamma_10000,beta_gamma_10000};
		
	}
	
	//transform ChIP-seq data into normalized epigenomics data for 1kb intervals
	public static double[][] p_1000(double[][][] chromatin_1000, int[][] count_1000, double[][] coverage){
		double[][] avg_1000=new double[4][100];
		double[][] avg_1000_2=new double[4][100];
		for (int i=0;i<count_1000.length;i++){
			for (int j=0;j<count_1000[i].length;j++){
				if(low(chr[i])<=coverage[i][j/10]&&coverage[i][j/10]<=high(chr[i])){
					for (int k=0;k<4;k++){
						if(-4<=chromatin_1000[i][j][k]&&chromatin_1000[i][j][k]<10){
							int z=(int)(100*(chromatin_1000[i][j][k]+4)/14.0);
							avg_1000[k][z]+=count_1000[i][j];
							avg_1000_2[k][z]+=1;
						}
					}
				
				}
			}
		}
		
		
		for (int i=0;i<avg_1000.length;i++){
			for (int j=0;j<avg_1000[i].length;j++){
				if(avg_1000_2[i][j]>0){
					avg_1000[i][j]/=avg_1000_2[i][j];
				}
			}
		}
		
		double[][] p_1000=new double[4][100];
		for (int k=0;k<4;k++){
			ArrayList<Double> x=new ArrayList<Double>();
			for (int i=0;i<avg_1000[k].length;i++){
				x.add(avg_1000[k][i]);
			}
			Collections.sort(x);
			double max_90_1000=x.get((int)(0.1*x.size()));
			if(k==2){
				max_90_1000=x.get((int)(0.9*x.size()));
			}
			for (int i=0;i<p_1000[k].length;i++){
				p_1000[k][i]=(avg_1000[k][i]-avg_1000[k][0])/(max_90_1000-avg_1000[k][0]);
			}
			
			double max=0;
			for (int i=0;i<p_1000[k].length;i++){
				if(p_1000[k][i]>max){
					max=p_1000[k][i];
				}
				p_1000[k][i]=max;
			}
		}
		return p_1000;
	}
	
	//transform ChIP-seq data into normalized epigenomics data for 10kb intervals
	public static double[][] p_10000(double[][][] chromatin_10000, int[][] count_10000, double[][] coverage){
		double[][] avg_10000=new double[4][100];
		double[][] avg_10000_2=new double[4][100];
		for (int i=0;i<count_10000.length;i++){
			for (int j=0;j<count_10000[i].length;j++){
				if(low(chr[i])<=coverage[i][j]&&coverage[i][j]<=high(chr[i])){
					for (int k=0;k<4;k++){
						if(-4<=chromatin_10000[i][j][k]&&chromatin_10000[i][j][k]<10){
							int z=(int)(100*(chromatin_10000[i][j][k]+4)/14.0);
							avg_10000[k][z]+=count_10000[i][j];
							avg_10000_2[k][z]+=1;
						}
					}
				
				}
			}
		}
		
		for (int i=0;i<avg_10000.length;i++){
			for (int j=0;j<avg_10000[i].length;j++){
				if(avg_10000_2[i][j]>0){
					avg_10000[i][j]/=avg_10000_2[i][j];
				}
				
			}
		}
		
		double[][] p_10000=new double[4][100];
		for (int k=0;k<4;k++){
			ArrayList<Double> x=new ArrayList<Double>();
			for (int i=0;i<avg_10000[k].length;i++){
				x.add(avg_10000[k][i]);
			}
			Collections.sort(x);
			double max_90_10000=x.get((int)(0.1*x.size()));
			if(k==2){
				max_90_10000=x.get((int)(0.9*x.size()));
			}
			
			for (int i=0;i<p_10000[k].length;i++){
				p_10000[k][i]=(avg_10000[k][i]-avg_10000[k][0])/(max_90_10000-avg_10000[k][0]);
			}
			
			
			double max=0;
			for (int i=0;i<p_10000[k].length;i++){
				if(p_10000[k][i]>max){
					max=p_10000[k][i];
				}
				p_10000[k][i]=max;
			}
		}
		
		return p_10000;
	}
	
	//count number of mutations for 1kb intervals
	public static int[][] count_1000(ArrayList<Mutation>[][] mutations){
		int[][] count_1000=new int[chr.length][];
		for (int i=0;i<mutations.length;i++){
			count_1000[i]=new int[1+(chr_length[i]-shift_mut)/1000];
			for (int j=0;j<mutations[i].length;j++){
				for (int k=0;k<mutations[i][j].size();k++){
					if(mutations[i][j].get(k).group==0){//||mutations[i][j].get(k).group==1
						count_1000[i][(int)((mutations[i][j].get(k).pos-10000*j-shift_mut)/1000)+10*j]++;
					}
				}
			}
		}
		return count_1000;
		
	}
	
	//count number of indels for 1kb intervals
	public static int[][] count_1000_indel(ArrayList<Mutation>[][] mutations){
		
		int[][] count_1000=new int[chr.length][];
		for (int i=0;i<mutations.length;i++){
			count_1000[i]=new int[1+(chr_length[i]-shift_mut)/1000];
			for (int j=0;j<mutations[i].length;j++){
				for (int k=0;k<mutations[i][j].size();k++){
					if(mutations[i][j].get(k).group==0){//||mutations[i][j].get(k).group==1
						if(mutations[i][j].get(k).ref.length()==1&&mutations[i][j].get(k).alt.length()==1){
							
						}
						else{
							count_1000[i][(int)((mutations[i][j].get(k).pos-10000*j-shift_mut)/1000)+10*j]++;
						}
						
					}
				}
			}
		}
		return count_1000;
		
	}
	
	//count number of mutations for 10kb intervals
	public static int[][] count_10000(ArrayList<Mutation>[][] mutations){
		
		int[][] count_10000=new int[chr.length][];
		for (int i=0;i<mutations.length;i++){
			count_10000[i]=new int[1+(chr_length[i]-shift_mut)/10000];
			for (int j=0;j<mutations[i].length;j++){
				for (int k=0;k<mutations[i][j].size();k++){
					if(mutations[i][j].get(k).group==0){//||mutations[i][j].get(k).group==1
						count_10000[i][j]++;
					}
				}
			}
		}
		return count_10000;
		
	}
	
	//count number of indels for 10kb intervals
	public static int[][] count_10000_indel(ArrayList<Mutation>[][] mutations){
		
		int[][] count_10000=new int[chr.length][];
		for (int i=0;i<mutations.length;i++){
			count_10000[i]=new int[1+(chr_length[i]-shift_mut)/10000];
			for (int j=0;j<mutations[i].length;j++){
				for (int k=0;k<mutations[i][j].size();k++){
					if(mutations[i][j].get(k).group==0){//||mutations[i][j].get(k).group==1
						if(mutations[i][j].get(k).ref.length()==1&&mutations[i][j].get(k).alt.length()==1){
						}
						else{
							count_10000[i][j]++;
							
						}
					}
				}
			}
		}
		return count_10000;
		
	}
	
	//read ChIP-seq data for 1kb intervals
	public static double[][][] read_chromatin_1000() throws java.io.IOException {
		double[][][] chromatin_1000=new double[chr.length][][];
		{
			for (int chr_index=0;chr_index<chr.length;chr_index++){
				chromatin_1000[chr_index]=new double[1+(chr_length[chr_index]-shift_mut)/1000][4];
				java.io.InputStream in=ZipOverlay.fileInputStream(file_epi_signal_1000+chr[chr_index]+"_"+shift_mut+".txt");
				BufferedReader input= new BufferedReader(new InputStreamReader(ZipFilter.filterInputStream(in)));
				input.readLine();
				String s="";
				while((s=input.readLine())!=null){
					String[] t=s.split("	");
					if(Integer.parseInt(t[0])>=shift_mut){
						chromatin_1000[chr_index][(Integer.parseInt(t[0])-shift_mut)/1000][0]=Double.parseDouble(t[1]);//H3K27me3
						chromatin_1000[chr_index][(Integer.parseInt(t[0])-shift_mut)/1000][1]=Double.parseDouble(t[2]);//H3K4me1
						chromatin_1000[chr_index][(Integer.parseInt(t[0])-shift_mut)/1000][2]=Double.parseDouble(t[3]);//H3K9me3
						chromatin_1000[chr_index][(Integer.parseInt(t[0])-shift_mut)/1000][3]=Double.parseDouble(t[4]);//H3K36me3
						
					}
					
				
				}
				input.close();
				
				
				for (int j=0;j<chromatin_1000[chr_index].length;j++){
					chromatin_1000[chr_index][j][0]-=2;
				}
				
			}
		}
		return chromatin_1000;
	}
	
	
	//read ChIP-seq data for 10kb intervals
	public static double[][][] read_chromatin_10000() throws java.io.IOException {
		double[][][] chromatin_10000=new double[chr.length][][];
		{
			for (int chr_index=0;chr_index<chr.length;chr_index++){
				
				chromatin_10000[chr_index]=new double[1+(chr_length[chr_index]-shift_mut)/10000][4];
				java.io.InputStream in=ZipOverlay.fileInputStream(file_epi_signal_10000+chr[chr_index]+"_"+shift_mut+".txt");
				BufferedReader input= new BufferedReader(new InputStreamReader(ZipFilter.filterInputStream(in)));
				input.readLine();
				String s="";
				while((s=input.readLine())!=null){
					String[] t=s.split("	");
					if(Integer.parseInt(t[0])>=shift_mut){
						chromatin_10000[chr_index][(Integer.parseInt(t[0])-shift_mut)/10000][0]=Double.parseDouble(t[1]);//H3K27me3
						chromatin_10000[chr_index][(Integer.parseInt(t[0])-shift_mut)/10000][1]=Double.parseDouble(t[2]);//H3K4me1
						chromatin_10000[chr_index][(Integer.parseInt(t[0])-shift_mut)/10000][2]=Double.parseDouble(t[3]);//H3K9me3
						chromatin_10000[chr_index][(Integer.parseInt(t[0])-shift_mut)/10000][3]=Double.parseDouble(t[4]);//H3K36me3
					}
				}
				input.close();
				
				for (int j=0;j<chromatin_10000[chr_index].length;j++){
					chromatin_10000[chr_index][j][0]-=2;
				}
			}
		}
		return chromatin_10000;
	}
	
	//check for mutations in repetitive regions
	public static boolean is_msi1(Mutation mut, ArrayList<char[]> genome){
		
		int len_max=0;
		int rep_len_max=0;
		
		for (int rep_len=1;rep_len<=5;rep_len++){
			int k=0;
			while(genome(mut.pos+1,mut.pos+rep_len,genome).equals(genome(mut.pos+(k+1)*rep_len+1,mut.pos+(k+2)*rep_len,genome))){
				k++;
				if (k*rep_len>=5)   // NB. early exit for OOB
					return !mut.coding;
			}
			if(k*rep_len>len_max){
				len_max=k*rep_len;
				rep_len_max=rep_len;
			}
			
			k=0;
			while(genome(mut.pos-rep_len,mut.pos-1,genome).equals(genome(mut.pos-((k+2)*rep_len),mut.pos-((k+1)*rep_len+1),genome))){
				k++;
				if (k*rep_len>=5)
					return !mut.coding;
			}
			if(k*rep_len>len_max){
				len_max=k*rep_len;
				rep_len_max=rep_len;
			}
		}
		
		
		if(!mut.coding&&len_max>=5){
			return true;
		}
		
		return false;
		
	}

	//reference nucleotide(s) of Hg19
	public static String genome(int start_pos, int end_pos, ArrayList<char[]> genome){
		String g="";
		for (int pos=start_pos;pos<=end_pos;pos++){
			g=g+genome(pos,genome);
		}
		return g;
	}

	//check for mutations in MSI specific nucleotide contexts
	public static boolean is_msi2(Mutation mut, ArrayList<char[]> genome){
		
		int len2=0;
		boolean context_a=false;
		if(genome(mut.pos,genome)=='A'&&genome(mut.pos-1,genome)=='A'&&genome(mut.pos+1,genome)=='G'){
			context_a=true;
			while(genome(mut.pos+2+len2,genome)=='T'){
				len2++;
			}
		}
		else if(genome(mut.pos,genome)=='T'&&genome(mut.pos-1,genome)=='C'&&genome(mut.pos+1,genome)=='T'){
			context_a=true;
			while(genome(mut.pos-2-len2,genome)=='A'){
				len2++;
			}
		}
		
		if(!mut.coding&&context_a&&len2>=3){
			return true;
		}
		return false;
		
	}
	
	//main function called from outside to execute the script. the script first initializes the 
	//paths and global parameters based on outside parameters. it then reads mutations and annotation data
	//and calls the functions to compute the different p-values for each 10kb interval described in the methods
	//finally, it writes these p-values to a combined significance file
	public static void execute(String entity_sel, int shift_mut, String folder_auxiliary, String folder_significance,String folder_annotation,String folder_counts_all, String[] all_entities, String[][] files_donors, String[][][] files_mut_snv, String[][][] files_mut_indel) throws java.io.IOException {
		boolean isWindows = System.getProperty("os.name").toLowerCase().startsWith("windows");
		if(isWindows){
			separator="\\";
		}
		else{
			separator="/";
		}
		
		initiate( entity_sel,  shift_mut,  folder_auxiliary,  folder_significance, folder_annotation, folder_counts_all,  all_entities,files_donors, files_mut_snv, files_mut_indel);
		if(!ZipOverlay.exists(new File(folder_annotation))){
			return;
		}
		if(!new File(folder_auxiliary).exists()){
			new File(folder_auxiliary).mkdir();
		}
		if(!new File(subfolder_auxiliary).exists()){
			new File(subfolder_auxiliary).mkdir();
		}
		if(!new File(folder_significance).exists()){
			new File(folder_significance).mkdir();
		}
		if(!new File(folder_counts_all).exists()){
			new File(folder_counts_all).mkdir();
		}
		
		
		
		
		mutations=new ArrayList[chr.length][];
		
		interval_align=new ArrayList[chr.length][];
		coverage=null;
		
		{
			coverage=read_coverage();
			
			if(!new File(file_n_indel_quality2).exists()||!new File(file_n_quality2).exists()){
				read_mutations_entitites(all_entities);
			}
			//System.exit(0);
			
			System.out.println("Start read");
			read_mutations(entity_sel);//ArrayList<Mutation>[][] mutations=
			System.gc();
			System.out.println("Done read");
			
			int[][][] splice=new int[chr.length][][];
			int[][] splice_total=new int[chr.length][];
			
			if(!new File(file_splice_count).exists()){
				SubthreadSplice[] threads=new SubthreadSplice[chr.length];
				for (int i=0;i<threads.length;i++){
					threads[i]=new SubthreadSplice();
					threads[i].i=i;
					threads[i].coverage=coverage;
					threads[i].mutations=mutations;
					threads[i].start();
				}
				
				boolean all_done=false;
				while(!all_done){
					all_done=true;
					for (int i=0;i<threads.length;i++){
						if(threads[i].status!=2){
							all_done=false;
						}
					}
					try{
					Thread.sleep(250);
					}
					catch(java.lang.InterruptedException error){
					}
				}
				
				for (int i=0;i<splice.length;i++){
					splice[i]=threads[i].splice;
					splice_total[i]=threads[i].splice_total;
				}
				
				java.io.FileOutputStream out=new java.io.FileOutputStream(file_splice_count);
				BufferedWriter output= new BufferedWriter(new java.io.OutputStreamWriter(ZipFilter.filterOutputStream(out, file_splice_count)));
				for (int i=0;i<splice.length;i++){
					for (int j=0;j<splice[i].length;j++){
						output.write(i+"	"+j+"	"+splice_total[i][j]+"	"+splice[i][j][0]+"	"+splice[i][j][1]);
						output.newLine();
					}
				}
				output.close();
			}
			else{
				for (int i=0;i<chr.length;i++){
					splice[i]=new int[1+(chr_length[i]-shift_mut)/10000][2];
					splice_total[i]=new int[1+(chr_length[i]-shift_mut)/10000];
				}
				
				FileInputStream in=new FileInputStream(file_splice_count);
				BufferedReader input= new BufferedReader(new InputStreamReader(ZipFilter.filterInputStream(in)));
				String s="";
				while((s=input.readLine())!=null){
					String[] t=s.split("	");
					splice_total[Integer.parseInt(t[0])][Integer.parseInt(t[1])]=Integer.parseInt(t[2]);
					splice[Integer.parseInt(t[0])][Integer.parseInt(t[1])][0]=Integer.parseInt(t[3]);
					splice[Integer.parseInt(t[0])][Integer.parseInt(t[1])][1]=Integer.parseInt(t[4]);
					
				}
				input.close();
			}
			
			double n1=0;
			double n2=0;
			for (int i=0;i<splice.length;i++){
				for (int j=0;j<splice[i].length;j++){
					n1+=splice[i][j][1];
					n2+=splice_total[i][j];
				}
			}
			
			ArrayList<double[]> splice_raw=new ArrayList<double[]>();
			for (int i=0;i<splice.length;i++){
				for (int j=0;j<splice[i].length;j++){
					if(low(chr[i])<=coverage[i][j]&&coverage[i][j]<high(chr[i])){
						double aX=1;
						double bX=1;
						if(splice[i][j][1]>0){
							aX=Math.max(0,1-new BinomialDistribution(splice_total[i][j],n1/n2).cumulativeProbability(splice[i][j][1]-1));//Math.pow(10, -10)
							if(splice[i][j][1]>1){
								bX=Math.max(0,1-new BinomialDistribution(splice_total[i][j],n1/n2).cumulativeProbability(splice[i][j][1]-2));//Math.pow(10, -10)
							}
							splice_raw.add(new double[]{splice[i][j][1],splice_total[i][j],i,j,aX,bX});
							
						}
					}
				}
			}
			
			Comparator<double[]> comp_splice=(double[] x, double[] y)->{
				if((int)(x[0])==(int)(y[0])){
					return new Integer((int)(x[1])).compareTo((int)(y[1]));
				}
				return -new Integer((int)(x[0])).compareTo((int)(y[0]));
			};
			
			Collections.sort(splice_raw,comp_splice);
			
			double[][] p_splice=new double[chr.length][];
			for (int i=0;i<chr.length;i++){
				p_splice[i]=new double[(int)(1+(chr_length[i]-shift_mut)/10000)];
				for (int j=0;j<p_splice[i].length;j++){
					p_splice[i][j]=1.0;
				}
			}
			
			int[] nn=new int[20];
			for (int i=0;i<splice_raw.size();i++){
				nn[Math.min(19, (int)(splice_raw.get(i)[0]))]++;
			}
			int[] nnn=new int[20];
			for (int i=0;i<splice_raw.size();i++){
				p_splice[(int)(splice_raw.get(i)[2])][(int)(splice_raw.get(i)[3])]=(double)(nnn[Math.min(19, (int)(splice_raw.get(i)[0]))]+1)/(double)(nn[Math.min(19, (int)(splice_raw.get(i)[0]))]+1)*(splice_raw.get(i)[4+1]-splice_raw.get(i)[3+1])+splice_raw.get(i)[3+1];
				nnn[Math.min(19, (int)(splice_raw.get(i)[0]))]++;
			}
			
			
			ArrayList<int[]> counts_all=new ArrayList<int[]>();
			for (int i=0;i<mutations.length;i++){
				for (int j=0;j<mutations[i].length;j++){
					if(low(chr[i])<=coverage[i][j]&&coverage[i][j]<high(chr[i])){
							
						Hashtable<Integer,Integer> table=new Hashtable<Integer,Integer>();
						ArrayList<int[]> counts=new ArrayList<int[]>();
						for (int k=0;k<mutations[i][j].size();k++){
							if(mutations[i][j].get(k).group==0){
								Integer ii=table.get(mutations[i][j].get(k).pos);
								if(ii==null){
									ii=counts.size();
									table.put(mutations[i][j].get(k).pos,counts.size());
									counts.add(new int[]{i,mutations[i][j].get(k).pos,0});
								}
								counts.get(ii)[2]++;
							}
							
						}
						
						for (int k=0;k<counts.size();k++){
							if(counts.get(k)[2]>=5){
								counts_all.add(counts.get(k));
							}
						}
					}
				}
			}
			
			Comparator<int[]> comp2=(int[] x, int[] y)->{
				return -new Integer(x[2]).compareTo(y[2]);
			}; 
			
			Hashtable<Integer,Integer>[] table_skip=new Hashtable[chr.length];
			for (int i=0;i<table_skip.length;i++){
				table_skip[i]=new Hashtable<Integer,Integer>();
			}
			if(counts_all.size()>0){
				Collections.sort(counts_all,comp2);
				for (int i=0;i<Math.min(10, counts_all.size());i++){
					table_skip[counts_all.get(i)[0]].put((int)((counts_all.get(i)[1]-shift_mut)/10000),i);
				}
			}
			
			
			double[] factor_clumps=new double[10000];
			if(!new File(file_factor_clumps).exists()){
				
				SubthreadClumpsDistance[] threads_dist=new SubthreadClumpsDistance[chr.length];
				for (int i=0;i<threads_dist.length;i++){
					threads_dist[i]=new SubthreadClumpsDistance();
					threads_dist[i].i=i;
					threads_dist[i].coverage=coverage;
					threads_dist[i].table_skip=table_skip[i];
					threads_dist[i].mutations=mutations;
					threads_dist[i].start();
				}
				
				boolean all_done=false;
				while(!all_done){
					all_done=true;
					for (int i=0;i<threads_dist.length;i++){
						if(threads_dist[i].status!=2){
							all_done=false;
						}
					}
					try{
					Thread.sleep(250);
					}
					catch(java.lang.InterruptedException e){
					}
				}
				
				int[] expected_combi=new int[10000];
				int[] observed_combi=new int[10000];
				for (int i=0;i<threads_dist.length;i++){
					add(expected_combi,threads_dist[i].expected);
					add(observed_combi,threads_dist[i].observed);
				}
				
				long sum_expected=0;
				long sum_observed=0;
				for (int i=0;i<expected_combi.length;i++){
					sum_expected+=expected_combi[i];
					sum_observed+=observed_combi[i];
				}
				System.out.println(sum_expected+"	"+sum_observed);
				
				for (int i=0;i<expected_combi.length;i++){
					if(i<100){
						factor_clumps[i]=Math.exp(Math.log(observed_combi[i])+Math.log(sum_expected)-Math.log(expected_combi[i])-Math.log(sum_observed));//(double)(observed_combi[i]*sum_expected)/(expected_combi[i]*sum_observed);
					}
					else{
						factor_clumps[i]=1.0;
					}
					
				}
				factor_clumps[0]*=0.5;
				
				java.io.FileOutputStream out=new java.io.FileOutputStream(file_factor_clumps);
				BufferedWriter output= new BufferedWriter(new java.io.OutputStreamWriter(ZipFilter.filterOutputStream(out, file_factor_clumps)));
				for (int i=0;i<factor_clumps.length;i++){
					
					output.write(i+"	"+factor_clumps[i]);
					output.newLine();
					
				}
				output.close();
					
			}
			else{
				FileInputStream in=new FileInputStream(file_factor_clumps);
				BufferedReader input= new BufferedReader(new InputStreamReader(ZipFilter.filterInputStream(in)));
				String s="";
				while((s=input.readLine())!=null){
					String[] t=s.split("	");
					factor_clumps[Integer.parseInt(t[0])]=Double.parseDouble(t[1]);
				}
				input.close();			
			}

			ArrayList<int[]> counts_all_indel=new ArrayList<int[]>();
			for (int i=0;i<mutations.length;i++){
				for (int j=0;j<mutations[i].length;j++){
					if(low(chr[i])<=coverage[i][j]&&coverage[i][j]<high(chr[i])){
							
						Hashtable<Integer,Integer> table_indel=new Hashtable<Integer,Integer>();
						ArrayList<int[]> counts_indel=new ArrayList<int[]>();
						for (int k=0;k<mutations[i][j].size();k++){
							if(mutations[i][j].get(k).ref.length()!=1||mutations[i][j].get(k).alt.length()!=1&&mutations[i][j].get(k).group==0){
								Integer ii=table_indel.get(mutations[i][j].get(k).pos);
								if(ii==null){
									ii=counts_indel.size();
									table_indel.put(mutations[i][j].get(k).pos,counts_indel.size());
									counts_indel.add(new int[]{i,mutations[i][j].get(k).pos,0});
								}
								counts_indel.get(ii)[2]++;
							}
							
							
						}
						
						for (int k=0;k<counts_indel.size();k++){
							if(counts_indel.get(k)[2]>=5){
								counts_all_indel.add(counts_indel.get(k));
							}
						}
					}
				}
			}
			
			Hashtable<Integer,Integer>[] table_skip_indel=new Hashtable[chr.length];
			for (int i=0;i<table_skip_indel.length;i++){
				table_skip_indel[i]=new Hashtable<Integer,Integer>();
			}
			if(counts_all_indel.size()>0){
				Collections.sort(counts_all_indel,comp2);
				
				for (int i=0;i<Math.min(10, counts_all_indel.size());i++){
					table_skip_indel[counts_all_indel.get(i)[0]].put((int)((counts_all_indel.get(i)[1]-shift_mut)/10000),i);
				}
			}
			
			double[] factor_clumps_indel=new double[10000];
			if(!new File(file_factor_clumps_indel).exists()){
				
				SubthreadClumpsDistance_indel[] threads_dist_indel=new SubthreadClumpsDistance_indel[chr.length];
				for (int i=0;i<threads_dist_indel.length;i++){
					threads_dist_indel[i]=new SubthreadClumpsDistance_indel();
					threads_dist_indel[i].i=i;
					threads_dist_indel[i].coverage=coverage;
					threads_dist_indel[i].table_skip=table_skip_indel[i];
					threads_dist_indel[i].mutations=mutations;
					threads_dist_indel[i].start();
				}
				
				boolean all_done=false;
				while(!all_done){
					all_done=true;
					for (int i=0;i<threads_dist_indel.length;i++){
						if(threads_dist_indel[i].status!=2){
							all_done=false;
						}
					}
					try{
					Thread.sleep(250);
					}
					catch(java.lang.InterruptedException e){
					}
				}
				
				int[] expected_combi_indel=new int[10000];
				int[] observed_combi_indel=new int[10000];
				for (int i=0;i<threads_dist_indel.length;i++){
					add(expected_combi_indel,threads_dist_indel[i].expected);
					add(observed_combi_indel,threads_dist_indel[i].observed);
				}
				
				long sum_expected_indel=0;
				long sum_observed_indel=0;
				for (int i=0;i<expected_combi_indel.length;i++){
					sum_expected_indel+=expected_combi_indel[i];
					sum_observed_indel+=observed_combi_indel[i];
				}
				System.out.println(sum_expected_indel+"	"+sum_observed_indel);
				
				for (int i=0;i<expected_combi_indel.length;i++){
					if(i<100){
						factor_clumps_indel[i]=Math.exp(Math.log(observed_combi_indel[i])+Math.log(sum_expected_indel)-Math.log(expected_combi_indel[i])-Math.log(sum_observed_indel));//(double)(observed_combi[i]*sum_expected)/(expected_combi[i]*sum_observed);
					}
					else{
						factor_clumps_indel[i]=1.0;
					}
					
				}
				factor_clumps_indel[0]*=0.5;
				
				java.io.FileOutputStream out=new java.io.FileOutputStream(file_factor_clumps_indel);
				BufferedWriter output= new BufferedWriter(new java.io.OutputStreamWriter(ZipFilter.filterOutputStream(out, file_factor_clumps_indel)));
				for (int i=0;i<factor_clumps_indel.length;i++){
					
					output.write(i+"	"+factor_clumps_indel[i]);
					output.newLine();
					
				}
				output.close();
					
			}
			else{
				FileInputStream in=new FileInputStream(file_factor_clumps_indel);
				BufferedReader input= new BufferedReader(new InputStreamReader(ZipFilter.filterInputStream(in)));
				String s="";
				while((s=input.readLine())!=null){
					String[] t=s.split("	");
					factor_clumps_indel[Integer.parseInt(t[0])]=Double.parseDouble(t[1]);
				}
				input.close();			
			}
		
			double[][] clumps_combi=new double[chr.length][];
			double[][] avg_clumps_combi=new double[chr.length][];
			
			if(!new File(file_clumps_count_combi).exists()){
				SubthreadClumpsCombi[] threads_combi=new SubthreadClumpsCombi[chr.length];
				for (int i=0;i<threads_combi.length;i++){
					threads_combi[i]=new SubthreadClumpsCombi();
					threads_combi[i].i=i;
					threads_combi[i].coverage=coverage;
					threads_combi[i].mutations=mutations;
					threads_combi[i].factor_clumps=factor_clumps;
					threads_combi[i].start();
				}
				
				boolean all_done=false;
				while(!all_done){
					all_done=true;
					for (int i=0;i<threads_combi.length;i++){
						if(threads_combi[i].status!=2){
							all_done=false;
						}
					}
					try{
					Thread.sleep(250);
					}
					catch(java.lang.InterruptedException e){
					}
				}
				
				for (int i=0;i<threads_combi.length;i++){
					avg_clumps_combi[i]=threads_combi[i].avg_clumps;
					clumps_combi[i]=threads_combi[i].clumps;
				}
				
				
				java.io.FileOutputStream out=new java.io.FileOutputStream(file_clumps_count_combi);
				BufferedWriter output= new BufferedWriter(new java.io.OutputStreamWriter(ZipFilter.filterOutputStream(out, file_clumps_count_combi)));
				for (int i=0;i<clumps_combi.length;i++){
					for (int j=0;j<clumps_combi[i].length;j++){
						output.write(i+"	"+j+"	"+clumps_combi[i][j]+"	"+avg_clumps_combi[i][j]);
						output.newLine();
					}
				}
				output.close();
			}
			else{
				
				for (int i=0;i<chr.length;i++){
					clumps_combi[i]=new double[1+(chr_length[i]-shift_mut)/10000];
					avg_clumps_combi[i]=new double[1+(chr_length[i]-shift_mut)/10000];
				}
				
				FileInputStream in=new FileInputStream(file_clumps_count_combi);
				BufferedReader input= new BufferedReader(new InputStreamReader(ZipFilter.filterInputStream(in)));
				String s="";
				while((s=input.readLine())!=null){
					String[] t=s.split("	");
					clumps_combi[Integer.parseInt(t[0])][Integer.parseInt(t[1])]=Double.parseDouble(t[2]);
					avg_clumps_combi[Integer.parseInt(t[0])][Integer.parseInt(t[1])]=Double.parseDouble(t[3]);
					
				}
				input.close();
			}

			
			double[][] clumps_combi_indel=new double[chr.length][];
			double[][] avg_clumps_combi_indel=new double[chr.length][];
			
			if(!new File(file_clumps_count_combi_indel).exists()){
				SubthreadClumpsCombi_indel[] threads_combi_indel=new SubthreadClumpsCombi_indel[chr.length];
				for (int i=0;i<threads_combi_indel.length;i++){
					threads_combi_indel[i]=new SubthreadClumpsCombi_indel();
					threads_combi_indel[i].i=i;
					threads_combi_indel[i].coverage=coverage;
					threads_combi_indel[i].mutations=mutations;
					threads_combi_indel[i].factor_clumps=factor_clumps_indel;
					threads_combi_indel[i].start();
				}
				
				boolean all_done=false;
				while(!all_done){
					all_done=true;
					for (int i=0;i<threads_combi_indel.length;i++){
						if(threads_combi_indel[i].status!=2){
							all_done=false;
						}
					}
					try{
					Thread.sleep(250);
					}
					catch(java.lang.InterruptedException e){
					}
				}
				
				for (int i=0;i<threads_combi_indel.length;i++){
					avg_clumps_combi_indel[i]=threads_combi_indel[i].avg_clumps;
					clumps_combi_indel[i]=threads_combi_indel[i].clumps;
				}
				
				
				java.io.FileOutputStream out=new java.io.FileOutputStream(file_clumps_count_combi_indel);
				BufferedWriter output= new BufferedWriter(new java.io.OutputStreamWriter(ZipFilter.filterOutputStream(out, file_clumps_count_combi_indel)));
				for (int i=0;i<clumps_combi_indel.length;i++){
					for (int j=0;j<clumps_combi_indel[i].length;j++){
						output.write(i+"	"+j+"	"+clumps_combi_indel[i][j]+"	"+avg_clumps_combi_indel[i][j]);
						output.newLine();
					}
				}
				output.close();
			}
			else{
				
				for (int i=0;i<chr.length;i++){
					clumps_combi_indel[i]=new double[1+(chr_length[i]-shift_mut)/10000];
					avg_clumps_combi_indel[i]=new double[1+(chr_length[i]-shift_mut)/10000];
				}
				
				FileInputStream in=new FileInputStream(file_clumps_count_combi_indel);
				BufferedReader input= new BufferedReader(new InputStreamReader(ZipFilter.filterInputStream(in)));
				String s="";
				while((s=input.readLine())!=null){
					String[] t=s.split("	");
					clumps_combi_indel[Integer.parseInt(t[0])][Integer.parseInt(t[1])]=Double.parseDouble(t[2]);
					avg_clumps_combi_indel[Integer.parseInt(t[0])][Integer.parseInt(t[1])]=Double.parseDouble(t[3]);
					
				}
				input.close();
			}
						
			double max_factor_combi1=0;
			double max_factor_combi2=0;
			if(!new File(file_max_factor).exists()){
				double[] x=max_factor(clumps_combi,avg_clumps_combi,coverage);
				max_factor_combi1=x[0];
				max_factor_combi2=x[1];
				java.io.FileOutputStream out=new java.io.FileOutputStream(file_max_factor);
				BufferedWriter output= new BufferedWriter(new java.io.OutputStreamWriter(ZipFilter.filterOutputStream(out, file_max_factor)));
				output.write(max_factor_combi1+"	"+max_factor_combi2);
				output.newLine();
				output.close();
			}
			else{
				FileInputStream in=new FileInputStream(file_max_factor);
				BufferedReader input= new BufferedReader(new InputStreamReader(ZipFilter.filterInputStream(in)));
				String[] t=input.readLine().split("	");
				max_factor_combi1=Double.parseDouble(t[0]);
				max_factor_combi2=Double.parseDouble(t[1]);
				input.close();
			}
			
			double[][] p_clumps_combi=new double[chr.length][];
			for (int i=0;i<clumps_combi.length;i++){
				p_clumps_combi[i]=new double[1+(chr_length[i]-shift_mut)/10000];
				for (int j=0;j<clumps_combi[i].length;j++){
					if(low(chr[i])<=coverage[i][j]&&coverage[i][j]<high(chr[i])){
						double avg_c=avg_clumps_combi[i][j];
						double var_c=avg_clumps_combi[i][j]*max_factor_combi1+avg_clumps_combi[i][j]*avg_clumps_combi[i][j]*max_factor_combi2;
						double alpha=avg_c*avg_c/var_c;
						double beta=avg_c/var_c;
						
						if(clumps_combi[i][j]==0||avg_clumps_combi[i][j]==0){
							p_clumps_combi[i][j]=1.0;
						}
						else{
							p_clumps_combi[i][j]=1-cum_gamma(clumps_combi[i][j],alpha,beta);
						}
					}
					else{
						p_clumps_combi[i][j]=1.0;
					}
						
					
					
				}
			}

			double max_factor_combi_indel1=0;
			double max_factor_combi_indel2=0;
			if(!new File(file_max_factor_indel).exists()){
				double[] x=max_factor(clumps_combi_indel,avg_clumps_combi_indel,coverage);
				max_factor_combi_indel1=x[0];
				max_factor_combi_indel2=x[1];
				java.io.FileOutputStream out=new java.io.FileOutputStream(file_max_factor_indel);
				BufferedWriter output= new BufferedWriter(new java.io.OutputStreamWriter(ZipFilter.filterOutputStream(out, file_max_factor_indel)));
				output.write(max_factor_combi_indel1+"	"+max_factor_combi_indel2);
				output.newLine();
				output.close();
			}
			else{
				FileInputStream in=new FileInputStream(file_max_factor_indel);
				BufferedReader input= new BufferedReader(new InputStreamReader(ZipFilter.filterInputStream(in)));
				String[] t=input.readLine().split("	");
				max_factor_combi_indel1=Double.parseDouble(t[0]);
				max_factor_combi_indel2=Double.parseDouble(t[1]);
				input.close();
			}
			
			double[][] p_clumps_combi_indel=new double[chr.length][];
			for (int i=0;i<clumps_combi_indel.length;i++){
				p_clumps_combi_indel[i]=new double[1+(chr_length[i]-shift_mut)/10000];
				for (int j=0;j<clumps_combi_indel[i].length;j++){
					if(low(chr[i])<=coverage[i][j]&&coverage[i][j]<high(chr[i])){
						double avg_c_indel=avg_clumps_combi_indel[i][j];
						double var_c_indel=avg_clumps_combi_indel[i][j]*max_factor_combi_indel1+avg_clumps_combi_indel[i][j]*avg_clumps_combi_indel[i][j]*max_factor_combi_indel2;
						double alpha_indel=avg_c_indel*avg_c_indel/var_c_indel;
						double beta_indel=avg_c_indel/var_c_indel;
						
						if(clumps_combi_indel[i][j]==0||avg_clumps_combi_indel[i][j]==0){
							p_clumps_combi_indel[i][j]=1.0;
						}
						else{
							p_clumps_combi_indel[i][j]=1-cum_gamma(clumps_combi_indel[i][j],alpha_indel,beta_indel);
						}
					}
					else{
						p_clumps_combi_indel[i][j]=1.0;
					}
				}
			}
			
			double[][][] p_indel=null;
			if(!new File(file_p_indel).exists()||!new File(file_count_indel1).exists()||!new File(file_count_indel2).exists()){
				double[][][][] xxxx=read_counts_all_entities(file_n_indel_quality2,entity_sel,coverage);
				p_indel=xxxx[0];
				java.io.FileOutputStream out=new java.io.FileOutputStream(file_p_indel);
				BufferedWriter output= new BufferedWriter(new java.io.OutputStreamWriter(ZipFilter.filterOutputStream(out, file_p_indel)));
				for (int i=0;i<p_indel.length;i++){
					for (int j=0;j<p_indel[i].length;j++){
						output.write(i+"	"+j+"	"+p_indel[i][j][0]+"	"+p_indel[i][j][1]);
						output.newLine();
					}
				}
				output.close();
				
				double[][][] count_indel1=xxxx[1];
				double[][][] count_indel2=xxxx[2];
								
				out=new java.io.FileOutputStream(file_count_indel1);
				output= new BufferedWriter(new java.io.OutputStreamWriter(ZipFilter.filterOutputStream(out, file_count_indel1)));
				for (int i=0;i<count_indel1.length;i++){
					for (int j=0;j<count_indel1[i].length;j++){
						output.write(i+"	"+j+"	"+count_indel1[i][j][0]+"	"+count_indel1[i][j][1]+"	"+count_indel1[i][j][2]);
						output.newLine();
					}
				}
				output.close();
				
				out=new java.io.FileOutputStream(file_count_indel2);
				output= new BufferedWriter(new java.io.OutputStreamWriter(ZipFilter.filterOutputStream(out, file_count_indel2)));
				for (int i=0;i<count_indel2.length;i++){
					for (int j=0;j<count_indel2[i].length;j++){
						output.write(i+"	"+j+"	"+count_indel2[i][j][0]+"	"+count_indel2[i][j][1]+"	"+count_indel2[i][j][2]);
						output.newLine();
					}
				}
				output.close();
				
			}
			else{
				p_indel=new double[chr.length][][];
				for (int i=0;i<chr.length;i++){
					p_indel[i]=new double[1+(chr_length[i]-shift_mut)/10000][2];
				}
				FileInputStream in=new FileInputStream(file_p_indel);
				BufferedReader input= new BufferedReader(new InputStreamReader(ZipFilter.filterInputStream(in)));
				String s="";
				while((s=input.readLine())!=null){
					String[] t=s.split("	");
					p_indel[Integer.parseInt(t[0])][Integer.parseInt(t[1])][0]=Double.parseDouble(t[2]);
					p_indel[Integer.parseInt(t[0])][Integer.parseInt(t[1])][1]=Double.parseDouble(t[3]);
				}
				input.close();
			}
			
			double[][][] p_combi=null;
			if(!new File(file_p_combi).exists()||!new File(file_count_combi1).exists()||!new File(file_count_combi2).exists()){
				double[][][][] xxxx=read_counts_all_entities(file_n_quality2,entity_sel,coverage);
				p_combi=xxxx[0];
				java.io.FileOutputStream out=new java.io.FileOutputStream(file_p_combi);
				BufferedWriter output= new BufferedWriter(new java.io.OutputStreamWriter(ZipFilter.filterOutputStream(out, file_p_combi)));
				for (int i=0;i<p_combi.length;i++){
					for (int j=0;j<p_combi[i].length;j++){
						output.write(i+"	"+j+"	"+p_combi[i][j][0]+"	"+p_combi[i][j][1]);
						output.newLine();
					}
				}
				output.close();
				
				double[][][] count_combi1=xxxx[1];
				double[][][] count_combi2=xxxx[2];
				
				out=new java.io.FileOutputStream(file_count_combi1);
				output= new BufferedWriter(new java.io.OutputStreamWriter(ZipFilter.filterOutputStream(out, file_count_combi1)));
				for (int i=0;i<count_combi1.length;i++){
					for (int j=0;j<count_combi1[i].length;j++){
						output.write(i+"	"+j+"	"+count_combi1[i][j][0]+"	"+count_combi1[i][j][1]+"	"+count_combi1[i][j][2]);
						output.newLine();
					}
				}
				output.close();
				
				out=new java.io.FileOutputStream(file_count_combi2);
				output= new BufferedWriter(new java.io.OutputStreamWriter(ZipFilter.filterOutputStream(out, file_count_combi2)));
				for (int i=0;i<count_combi2.length;i++){
					for (int j=0;j<count_combi2[i].length;j++){
						output.write(i+"	"+j+"	"+count_combi2[i][j][0]+"	"+count_combi2[i][j][1]+"	"+count_combi2[i][j][2]);
						output.newLine();
					}
				}
				output.close();
				
			}
			else{
				p_combi=new double[chr.length][][];
				for (int i=0;i<chr.length;i++){
					p_combi[i]=new double[1+(chr_length[i]-shift_mut)/10000][2];
				}
				FileInputStream in=new FileInputStream(file_p_combi);
				BufferedReader input= new BufferedReader(new InputStreamReader(ZipFilter.filterInputStream(in)));
				String s="";
				while((s=input.readLine())!=null){
					String[] t=s.split("	");
					p_combi[Integer.parseInt(t[0])][Integer.parseInt(t[1])][0]=Double.parseDouble(t[2]);
					p_combi[Integer.parseInt(t[0])][Integer.parseInt(t[1])][1]=Double.parseDouble(t[3]);
				}
				input.close();
			}
			
			double[][][] chromatin_1000=read_chromatin_1000();
			double[][][] chromatin_10000=read_chromatin_10000();
			
			double[][][] sign_epigenomic_combi=null;
			if(!new File(file_p_epigenomic_combi).exists()||!new File(file_count_epigenomic_combi1).exists()||!new File(file_count_epigenomic_combi2).exists()){
				int[][] count_1000=count_1000(mutations);
				int[][] count_10000=count_10000(mutations);
				
				double[][][][] xxxx=sign_epigenomic( chromatin_1000,  chromatin_10000,  count_1000,  count_10000,  coverage);
				
				sign_epigenomic_combi=xxxx[0];
				
				double[][][] count_epigenomic_combi1=xxxx[1];
				double[][][] count_epigenomic_combi2=xxxx[2];
				
				java.io.FileOutputStream out=new java.io.FileOutputStream(file_count_epigenomic_combi1);
				BufferedWriter output= new BufferedWriter(new java.io.OutputStreamWriter(ZipFilter.filterOutputStream(out, file_count_epigenomic_combi1)));
				for (int i=0;i<count_epigenomic_combi1.length;i++){
					for (int j=0;j<count_epigenomic_combi1[i].length;j++){
						output.write(i+"	"+j+"	"+count_epigenomic_combi1[i][j][0]+"	"+count_epigenomic_combi1[i][j][1]+"	"+count_epigenomic_combi1[i][j][2]);
						output.newLine();
					}
				}
				output.close();
				
				out=new java.io.FileOutputStream(file_count_epigenomic_combi2);
				output= new BufferedWriter(new java.io.OutputStreamWriter(ZipFilter.filterOutputStream(out, file_count_epigenomic_combi2)));
				for (int i=0;i<count_epigenomic_combi2.length;i++){
					for (int j=0;j<count_epigenomic_combi2[i].length;j++){
						output.write(i+"	"+j+"	"+count_epigenomic_combi2[i][j][0]+"	"+count_epigenomic_combi2[i][j][1]+"	"+count_epigenomic_combi2[i][j][2]);
						output.newLine();
					}
				}
				output.close();
				
				
				out=new java.io.FileOutputStream(file_p_epigenomic_combi);
				output= new BufferedWriter(new java.io.OutputStreamWriter(ZipFilter.filterOutputStream(out, file_p_epigenomic_combi)));
				for (int i=0;i<sign_epigenomic_combi.length;i++){
					for (int j=0;j<sign_epigenomic_combi[i].length;j++){
						output.write(i+"	"+j+"	"+sign_epigenomic_combi[i][j][0]+"	"+sign_epigenomic_combi[i][j][1]);
						output.newLine();
					}
				}
				output.close();
			}
			else{
				sign_epigenomic_combi=new double[chr.length][][];
				for (int i=0;i<chr.length;i++){
					sign_epigenomic_combi[i]=new double[1+(chr_length[i]-shift_mut)/10000][2];
				}
				FileInputStream in=new FileInputStream(file_p_epigenomic_combi);
				BufferedReader input= new BufferedReader(new InputStreamReader(ZipFilter.filterInputStream(in)));
				String s="";
				while((s=input.readLine())!=null){
					String[] t=s.split("	");
					sign_epigenomic_combi[Integer.parseInt(t[0])][Integer.parseInt(t[1])][0]=Double.parseDouble(t[2]);
					sign_epigenomic_combi[Integer.parseInt(t[0])][Integer.parseInt(t[1])][1]=Double.parseDouble(t[3]);
				}
				input.close();
			}
			
			
			double[][][] sign_epigenomic_indel=null;
			if(!new File(file_p_epigenomic_indel).exists()||!new File(file_count_epigenomic_indel1).exists()||!new File(file_count_epigenomic_indel2).exists()){
				int[][] count_1000_indel=count_1000_indel(mutations);
				int[][] count_10000_indel=count_10000_indel(mutations);
				
				double[][][][] xxxx=sign_epigenomic( chromatin_1000,  chromatin_10000,  count_1000_indel,  count_10000_indel,  coverage);
				
				sign_epigenomic_indel=xxxx[0];
				double[][][] count_epigenomic_indel1=xxxx[1];
				double[][][] count_epigenomic_indel2=xxxx[2];
				
				java.io.FileOutputStream out=new java.io.FileOutputStream(file_count_epigenomic_indel1);
				BufferedWriter output= new BufferedWriter(new java.io.OutputStreamWriter(ZipFilter.filterOutputStream(out, file_count_epigenomic_indel1)));
				for (int i=0;i<count_epigenomic_indel1.length;i++){
					for (int j=0;j<count_epigenomic_indel1[i].length;j++){
						output.write(i+"	"+j+"	"+count_epigenomic_indel1[i][j][0]+"	"+count_epigenomic_indel1[i][j][1]+"	"+count_epigenomic_indel1[i][j][2]);
						output.newLine();
					}
				}
				output.close();
				
				out=new java.io.FileOutputStream(file_count_epigenomic_indel2);
				output= new BufferedWriter(new java.io.OutputStreamWriter(ZipFilter.filterOutputStream(out, file_count_epigenomic_indel2)));
				for (int i=0;i<count_epigenomic_indel2.length;i++){
					for (int j=0;j<count_epigenomic_indel2[i].length;j++){
						output.write(i+"	"+j+"	"+count_epigenomic_indel2[i][j][0]+"	"+count_epigenomic_indel2[i][j][1]+"	"+count_epigenomic_indel2[i][j][2]);
						output.newLine();
					}
				}
				output.close();
				
				
				out=new java.io.FileOutputStream(file_p_epigenomic_indel);
				output= new BufferedWriter(new java.io.OutputStreamWriter(ZipFilter.filterOutputStream(out, file_p_epigenomic_indel)));
				for (int i=0;i<sign_epigenomic_indel.length;i++){
					for (int j=0;j<sign_epigenomic_indel[i].length;j++){
						output.write(i+"	"+j+"	"+sign_epigenomic_indel[i][j][0]+"	"+sign_epigenomic_indel[i][j][1]);
						output.newLine();
					}
				}
				output.close();
			}
			else{
				sign_epigenomic_indel=new double[chr.length][][];
				for (int i=0;i<chr.length;i++){
					sign_epigenomic_indel[i]=new double[1+(chr_length[i]-shift_mut)/10000][2];
				}
				FileInputStream in=new FileInputStream(file_p_epigenomic_indel);
				BufferedReader input= new BufferedReader(new InputStreamReader(ZipFilter.filterInputStream(in)));
				String s="";
				while((s=input.readLine())!=null){
					String[] t=s.split("	");
					sign_epigenomic_indel[Integer.parseInt(t[0])][Integer.parseInt(t[1])][0]=Double.parseDouble(t[2]);
					sign_epigenomic_indel[Integer.parseInt(t[0])][Integer.parseInt(t[1])][1]=Double.parseDouble(t[3]);
				}
				input.close();
			}

			int[][] count_mut=new int[chr.length][];
			int[][] max_mut=new int[chr.length][];
			for (int i=0;i<chr.length;i++){
				count_mut[i]=new int[1+(chr_length[i]-shift_mut)/10000];
				max_mut[i]=new int[1+(chr_length[i]-shift_mut)/10000];
			}
			
			for (int i=0;i<mutations.length;i++){
				for (int j=0;j<mutations[i].length;j++){
					if(low(chr[i])<=coverage[i][j]&&coverage[i][j]<=high(chr[i])){
						count_mut[i][j]=0;
						Hashtable<Integer,Integer> table =new Hashtable<Integer,Integer>();
						ArrayList<int[]> counts=new ArrayList<int[]>();
						for (int k=0;k<mutations[i][j].size();k++){
							if(mutations[i][j].get(k).group==0){
								count_mut[i][j]++;
								Integer ii=table.get(mutations[i][j].get(k).pos);
								if(ii==null){
									ii=counts.size();
									table.put(mutations[i][j].get(k).pos,ii);
									counts.add(new int[]{mutations[i][j].get(k).pos,0});
								}
								counts.get(ii)[1]++;
							}
						}
						max_mut[i][j]=0;
						for (int k=0;k<counts.size();k++){
							if(counts.get(k)[1]>max_mut[i][j]){
								max_mut[i][j]=counts.get(k)[1];
							}
						}
					}
				}
			}
			
			SubthreadMaxCountFactor[] threads_factors=new SubthreadMaxCountFactor[90];
			double ff=1;
			for (int i=0;i<threads_factors.length;i++){
				threads_factors[i]=new SubthreadMaxCountFactor();
				threads_factors[i].coverage=coverage;
				threads_factors[i].n=count_mut;
				threads_factors[i].max=max_mut;		
				threads_factors[i].f=ff;
				ff*=1.1;
			}
			execute(threads_factors,30);
			
			int i_max=0;
			double mmax=-Double.MAX_VALUE;
			for (int i=0;i<threads_factors.length;i++){
				if(threads_factors[i].sum>mmax){
					mmax=threads_factors[i].sum;
					i_max=i;
				}
			}
			double f_max=threads_factors[i_max].f;
			
			double[][] p_hotspot=new double[chr.length][];
			for (int i=0;i<chr.length;i++){
				p_hotspot[i]=new double[1+(chr_length[i]-shift_mut)/10000];
				for (int j=0;j<p_hotspot[i].length;j++){
					p_hotspot[i][j]=1.0;
				}
			}
			
			for (int i=0;i<count_mut.length;i++){
				for (int j=0;j<count_mut[i].length;j++){
					if(low(chr[i])<=coverage[i][j]&&coverage[i][j]<=high(chr[i])){
						
						if(max_mut[i][j]>1&&alignability[i][j]>0.05){
							double eligible=alignability[i][j]*10000;
							double p1_bin=1;
							double p2_bin=1;
							
							p1_bin=Math.pow(new PoissonDistribution(count_mut[i][j]/eligible).cumulativeProbability(max_mut[i][j]-1),eligible-1)*new PoissonDistribution(count_mut[i][j]*f_max/eligible).cumulativeProbability(max_mut[i][j]-1);
							p2_bin=Math.pow(new PoissonDistribution(count_mut[i][j]/eligible).cumulativeProbability(max_mut[i][j]-2),eligible-1)*new PoissonDistribution(count_mut[i][j]*f_max/eligible).cumulativeProbability(max_mut[i][j]-2);
							p_hotspot[i][j]=1-(Math.random()*(p2_bin-p1_bin)+p1_bin);
							
						}
					}
				}
			}
			
	
			
			//From Destructive Component
			
			ArrayList<int[]> exons=new ArrayList<int[]>();
			java.io.InputStream in=ZipOverlay.fileInputStream(file_exons);
			BufferedReader input= new BufferedReader(new InputStreamReader(ZipFilter.filterInputStream(in)));
			String s="";
			while((s=input.readLine())!=null){
				String[] t=s.split("	");
				
				exons.add(new int[]{index(t[1],chr,chr2),Integer.parseInt(t[2])+2,Integer.parseInt(t[3])-2});
			}
			input.close();
			
			ArrayList<Integer>[][] indices=new ArrayList[chr.length][];
			for (int i=0;i<indices.length;i++){
				indices[i]=new ArrayList[1+chr_length[i]/10000];
				for (int j=0;j<indices[i].length;j++){
					indices[i][j]=new ArrayList<Integer>();
				}
			}
			for (int i=0;i<exons.size();i++){
				for(int j=(exons.get(i)[1]-5)/10000;j<=1+(exons.get(i)[2]+5)/10000;j++){
					if(j>=0){
						indices[exons.get(i)[0]][j].add(i);
					}
				}
			}
			int[][][] destructive=new int[chr.length][][];
			for (int i=0;i<mutations.length;i++){
				Hashtable<Integer,Integer> table_positions=new Hashtable<Integer,Integer>();
				ArrayList<Position> positions=new ArrayList<Position>();
			
				{ java.io.InputStream in1=ZipOverlay.fileInputStream(file_as_annotation+chr[i]+".txt");
				input= new BufferedReader(new InputStreamReader(ZipFilter.filterInputStream(in1))); }
				while((s=input.readLine())!=null){
					String[] t=s.split("	");
					if(t.length==7){
						table_positions.put(Integer.parseInt(t[0]), positions.size());
						positions.add(new Position(Integer.parseInt(t[0]),t[1],t[2],Integer.parseInt(t[3]),new String[]{t[4],t[5],t[6]}));
					}
				}
				input.close();
				destructive[i]=new int[1+(chr_length[i]-shift_mut)/10000][2];
				for (int j=0;j<mutations[i].length;j++){
					if(low(chr[i])<=coverage[i][j]&&coverage[i][j]<high(chr[i])){
						for (int k=0;k<mutations[i][j].size();k++){
							if(mutations[i][j].get(k).group==0){
								Integer ii=table_positions.get(mutations[i][j].get(k).pos);
								if(ii!=null){
									destructive[i][j][0]++;
									if(mutations[i][j].get(k).ref.length()==1&&mutations[i][j].get(k).alt.length()==1){
										int iii=index(mutations[i][j].get(k).ref,mutations[i][j].get(k).alt);
										if(positions.get(ii).alt_as[iii].equals("*")){
											destructive[i][j][1]++;//nonsense
										}
										else{
											int index_chr=i;
											int pos=mutations[i][j].get(k).pos;
											
											int min_dist=10000000;
											int dist=0;
											int border=-1;
											for (int kk=0;kk<indices[index_chr][pos/10000].size();kk++){
												if(Math.abs(pos-exons.get(indices[index_chr][pos/10000].get(kk))[1])<min_dist){
													min_dist=Math.abs(pos-exons.get(indices[index_chr][pos/10000].get(kk))[1]);
													dist=pos-exons.get(indices[index_chr][pos/10000].get(kk))[1];
													border=0;
												}
												if(Math.abs(pos-exons.get(indices[index_chr][pos/10000].get(kk))[2])<min_dist){
													min_dist=Math.abs(pos-exons.get(indices[index_chr][pos/10000].get(kk))[2]);
													dist=pos-exons.get(indices[index_chr][pos/10000].get(kk))[2];
													border=1;
												}
											}
											if((border==0&&-2<=dist&&dist<=1)||(border==1&&-1<=dist&&dist<=2)){
												destructive[i][j][1]++;//splice_site
											}
										}
									}
									else{
										destructive[i][j][1]++;//indel
									}
									
								}
							}
							
						}
					}
				}
				
			}
			int n_total=0;
			int n_destructive=0;
			for (int i=0;i<destructive.length;i++){
				for (int j=0;j<destructive[i].length;j++){
					n_total+=destructive[i][j][0];
					n_destructive+=destructive[i][j][1];//n[i][j][1]+n[i][j][2]+n[i][j][3];
				}
			}
			
			
			
			double f_destructive=(double)(n_destructive)/(double)(n_total);
			
			ArrayList<double[]> destructive_raw=new ArrayList<double[]>();
			for (int i=0;i<destructive.length;i++){
				for (int j=0;j<destructive[i].length;j++){
					if(low(chr[i])<=coverage[i][j]&&coverage[i][j]<high(chr[i])){
						double aX=1;
						double bX=1;
						if(destructive[i][j][1]>0){
							aX=Math.max(0,1-new BinomialDistribution(destructive[i][j][0],f_destructive).cumulativeProbability(destructive[i][j][1]-1));//Math.pow(10, -10)
							if(destructive[i][j][1]>1){
								bX=Math.max(0,1-new BinomialDistribution(destructive[i][j][0],f_destructive).cumulativeProbability(destructive[i][j][1]-2));//Math.pow(10, -10)
							}
							destructive_raw.add(new double[]{destructive[i][j][1],destructive[i][j][0],i,j,aX,bX});
						}
					}
				}
			}
			
			Comparator<double[]> comp_destructive=(double[] x, double[] y)->{
				if((int)(x[0])==(int)(y[0])){
					return new Integer((int)(x[1])).compareTo((int)(y[1]));
				}
				return -new Integer((int)(x[0])).compareTo((int)(y[0]));
			};
			
			Collections.sort(destructive_raw,comp_destructive);
			
			double[][] p_destructive=new double[chr.length][];
			for (int i=0;i<chr.length;i++){
				p_destructive[i]=new double[(int)(1+(chr_length[i]-shift_mut)/10000)];
				for (int j=0;j<p_destructive[i].length;j++){
					p_destructive[i][j]=1.0;
				}
			}
			
			int[] nn_destructive=new int[100];
			for (int i=0;i<destructive_raw.size();i++){
				nn_destructive[Math.min(99, (int)(destructive_raw.get(i)[0]))]++;
			}
			int[] nnn_destructive=new int[100];
			for (int i=0;i<destructive_raw.size();i++){
				p_destructive[(int)(destructive_raw.get(i)[2])][(int)(destructive_raw.get(i)[3])]=(double)(nnn_destructive[Math.min(99, (int)(destructive_raw.get(i)[0]))]+1)/(double)(nn_destructive[Math.min(99, (int)(destructive_raw.get(i)[0]))]+1)*(destructive_raw.get(i)[4+1]-destructive_raw.get(i)[3+1])+destructive_raw.get(i)[3+1];
				nnn_destructive[Math.min(99, (int)(destructive_raw.get(i)[0]))]++;
			}
			
			java.io.FileOutputStream out=new java.io.FileOutputStream(file_out_sign);
			BufferedWriter output= new BufferedWriter(new java.io.OutputStreamWriter(ZipFilter.filterOutputStream(out, file_out_sign)));
			output.write("Chr"+"	"+"Pos"+"	"+"p_splice"+"	"+"p_clumps_combi"+"	"+"p_clumps_combi_indel"+"	"+"p_indel_min"+"	"+"p_indel_large"+"	"+"p_combi_min"+"	"+"p_combi_large"+"	"+"sign_epigenomic_indel_large"+"	"+"sign_epigenomic_indel_min"+"	"+"sign_epigenomic_combi_large"+"	"+"sign_epigenomic_combi_min"+"	"+"p_hotspot"+"	"+"p_destructive");
			output.newLine();
			for (int i=0;i<chr.length;i++){
				for (int j=0;j<1+(chr_length[i]-shift_mut)/10000;j++){
					if(low(chr[i])<=coverage[i][j]&&coverage[i][j]<high(chr[i])){
						
						output.write(chr[i]+"	"+(j*10000+shift_mut)+"	"+p_splice[i][j]+"	"+p_clumps_combi[i][j]+"	"+p_clumps_combi_indel[i][j]+"	"+p_indel[i][j][0]+"	"+p_indel[i][j][1]+"	"+p_combi[i][j][0]+"	"+p_combi[i][j][1]+"	"+sign_epigenomic_indel[i][j][0]+"	"+sign_epigenomic_indel[i][j][1]+"	"+sign_epigenomic_combi[i][j][0]+"	"+sign_epigenomic_combi[i][j][1]+"	"+p_hotspot[i][j]+"	"+p_destructive[i][j]);
						output.newLine();
					}
				}
			}
			output.close();
			
		}
	}
	
	//method to compute count-based p-values based on the similarity of mutation rates between tumor types.
	//for this purpose, the method first reads the counts from all cancer types and esitmates the number of mutations 
	//in each interval based on similarity. based on this estimate, the method computes count-based p-values using a Gamma-Poisson distribution
	//for 1kb and 10kb intervals. it then combines p-values of neighboring 1kb intervals using Tippett's method 
	public static double[][][][] read_counts_all_entities(String file_count,String entity_sel , double[][] coverage) throws java.io.IOException {
		double[][][] p_result=new double[chr.length][][];
		int ll=1000;
		{
			FileInputStream in=new FileInputStream(file_count);
			BufferedReader input= new BufferedReader(new InputStreamReader(ZipFilter.filterInputStream(in)));
			String[] head=input.readLine().split("	");
			String[] entities=new String[head.length-2];
			for (int i=0;i<entities.length;i++){
				entities[i]=head[i+2];
			}
			
			double[][][] counts=new double[chr.length][][];
			double[][][] counts_2=new double[chr.length][][];//
			for (int i=0;i<counts.length;i++){
				counts[i]=new double[1+(chr_length[i]-shift_mut)/ll][entities.length];
				counts_2[i]=new double[1+(chr_length[i]-shift_mut)/ll][entities.length];
			}
			String s="";
			while((s=input.readLine())!=null){
				String[] t=s.split("	");
				for (int i=0;i<entities.length;i++){
					counts[index(t[0],chr)][(Integer.parseInt(t[1])-shift_mut)/1000][i]=Integer.parseInt(t[i+2]);
				}
			}
			input.close();
			
			double[][][] aavg=new double[chr.length][][];
			double[][] aavg2=new double[chr.length][];
			for (int i=0;i<aavg.length;i++){
				aavg[i]=new double[1+(chr_length[i]-shift_mut)/ll][entities.length];
				aavg2[i]=new double[1+(chr_length[i]-shift_mut)/ll];
			}
			for (int i=0;i<counts.length;i++){
				System.out.println(i);
				
				double[] x1=new double[entities.length];
				double x2=0;
				for (int k=-500000/ll;k<=500000/ll;k++){
					int j=0;//500000/ll;
					if(j+k>=0&&j+k<counts[i].length&&low(chr[i])<=coverage[i][(j+k)*ll/10000]&&coverage[i][(j+k)*ll/10000]<high(chr[i])){
						if((j*ll<mid_chr_length[i]-shift_mut&&(j+k)*ll<mid_chr_length[i]-shift_mut)||(j*ll>=mid_chr_length[i]-shift_mut&&(j+k)*ll>=mid_chr_length[i]-shift_mut)){
							for (int l=0;l<entities.length;l++){
								x1[l]+=counts[i][j+k][l];
							}
							x2++;
						}
					}
				}
				
				for (int j=0;j<counts[i].length;j++){
					int k=500000/ll;
					if(j+k>=0&&j+k<counts[i].length&&low(chr[i])<=coverage[i][(j+k)*ll/10000]&&coverage[i][(j+k)*ll/10000]<high(chr[i])){
						if((j*ll<mid_chr_length[i]-shift_mut&&(j+k)*ll<mid_chr_length[i]-shift_mut)||(j*ll>=mid_chr_length[i]-shift_mut&&(j+k)*ll>=mid_chr_length[i]-shift_mut)){
							for (int l=0;l<entities.length;l++){
								x1[l]+=counts[i][j+k][l];//x1[l];
							}
							x2++;
						}
					}
					k=-500000/ll-1;
					if(j+k>=0&&j+k<counts[i].length&&low(chr[i])<=coverage[i][(j+k)*ll/10000]&&coverage[i][(j+k)*ll/10000]<high(chr[i])){
						if((j*ll<mid_chr_length[i]-shift_mut&&(j+k)*ll<mid_chr_length[i]-shift_mut)||(j*ll>=mid_chr_length[i]-shift_mut&&(j+k)*ll>=mid_chr_length[i]-shift_mut)){
							for (int l=0;l<entities.length;l++){
								x1[l]-=counts[i][j+k][l];//x1[l];
							}
							x2--;
						}
					}
					
					if(low(chr[i])<=coverage[i][(j*ll)/10000]&&coverage[i][(j*ll)/10000]<high(chr[i])){
						for (int l=0;l<entities.length;l++){
							aavg[i][j][l]=x1[l];
						}
						aavg2[i][j]=x2;
					}
					
				}
			}
			
			for (int i=0;i<aavg.length;i++){
				for (int j=0;j<aavg[i].length;j++){
					for (int k=0;k<aavg[i][j].length;k++){
						if(aavg2[i][j]>10){
							aavg[i][j][k]/=aavg2[i][j];
						}
						else{
							aavg[i][j][k]=Double.NaN;
						}
					}
				}
			}
			
			
			
			for (int i=0;i<counts.length;i++){
				for (int j=0;j<counts[i].length;j++){
					for (int k=0;k<entities.length;k++){
						if(!Double.isNaN(aavg[i][j][k])&&aavg[i][j][k]!=0){
							counts_2[i][j][k]=(1+counts[i][j][k])/(1+aavg[i][j][k]);
						}
						else{
							counts_2[i][j][k]=0;
						}
					}
				}
			}
			
			int kkk=index(entity_sel,entities);
			
			int a=0;
			for (int i=0;i<counts.length;i++){
				for (int j=0;j<counts[i].length;j++){
					if(low(chr[i])<=coverage[i][j*ll/10000]&&coverage[i][j*ll/10000]<high(chr[i])&&counts_2[i][j][kkk]!=0){
						a++;
					}
					
				}
			}
			
			double[][] c_2=new double[a][entities.length-1];
			double[][] cc_2=new double[a][1];
			
			a=0;
			for (int i=0;i<counts.length;i++){
				for (int j=0;j<counts[i].length;j++){
					if(low(chr[i])<=coverage[i][j*ll/10000]&&coverage[i][j*ll/10000]<high(chr[i])&&counts_2[i][j][kkk]!=0){
						int b=0;
						for (int k=0;k<counts[i][j].length;k++){
							if(!entities[k].equals(entity_sel)){
								c_2[a][b]=counts_2[i][j][k];
								b++;
							}
							else{
								cc_2[a][0]=counts_2[i][j][k];
							}
						}
						a++;
					}
					
				}
			}

			Matrix X_2=new Matrix(c_2, a, entities.length-1);
			Matrix Y_2=new Matrix(cc_2, a, 1);
			Matrix bbeta_2=LSQSolve.solve(X_2, Y_2);

			
			double[] coef_global_2=new double[entities.length-1];
			double baseline_global_2=0;
			for (int i=0;i<entities.length-1;i++){
				coef_global_2[i]=bbeta_2.get(i, 0);
			}
			
			System.out.println("Baseline	"+baseline_global_2);
			for (int i=0;i<coef_global_2.length;i++){
				System.out.println(i+"	"+coef_global_2[i]);
			}
			
			double[][] count=new double[chr.length][];
			double[][] prediction=new double[chr.length][];
			for (int i=0;i<chr.length;i++){
				count[i]=new double[1+(chr_length[i]-shift_mut)/ll];
				prediction[i]=new double[1+(chr_length[i]-shift_mut)/ll];
			}
			
			for (int i=0;i<counts.length;i++){
				for (int j=0;j<counts[i].length;j++){
				
					double x_global_2=baseline_global_2;
					
					int b=0;
					int kk=-1;
					for (int k=0;k<counts[i][j].length;k++){
						if(!entities[k].equals(entity_sel)){
							x_global_2+=coef_global_2[b]*counts_2[i][j][k];	
							b++;
						}
						else{
							count[i][j]=counts[i][j][k];
							kk=k;
						}
					}
					if(!Double.isNaN(aavg[i][j][kk])){
						prediction[i][j]=x_global_2*(aavg[i][j][kk]+1)-1;//Math.exp()
					}
					else{
						prediction[i][j]=Double.NaN;
					}
					
				}
			}
			
			
			double[][] prediction_10=new double[chr.length][];
			double[][] counts_10=new double[chr.length][];
			for (int i=0;i<prediction.length;i++){
				prediction_10[i]=new double[1+(chr_length[i]-shift_mut)/10000];
				counts_10[i]=new double[1+(chr_length[i]-shift_mut)/10000];
				for (int j=0;j<prediction[i].length;j++){
					prediction_10[i][j/10]+=prediction[i][j];//Math.exp()
					counts_10[i][j/10]+=counts[i][j][kkk];//Math.exp()
				}
			}
			
			ArrayList<Double> p=new ArrayList<Double>();
			for (int i=0;i<count.length;i++){
				for (int j=0;j<count[i].length;j++){
					if(low(chr[i])<=coverage[i][j*ll/10000]&&coverage[i][j*ll/10000]<high(chr[i])){
						if(!Double.isNaN(prediction[i][j])){
							p.add(prediction[i][j]);
						}
						else{
							System.out.println("NaN	"+chr[i]+"	"+(j*ll)+"	"+prediction[i][j]);
						}
					}
					
				}
			}
			Collections.sort(p);
			
			double[] intervals=new double[99];
			for (int i=1;i<100;i++){
				intervals[i-1]=p.get((int)(p.size()*(double)(i)/100.0));
			}
			
			
			int[][] histo=new int[100][150];
			for (int i=0;i<count.length;i++){
				for (int j=0;j<count[i].length;j++){
					if(low(chr[i])<=coverage[i][j*ll/10000]&&coverage[i][j*ll/10000]<high(chr[i])){
						if(!Double.isNaN(prediction[i][j])){
							int ii=index(prediction[i][j],intervals);
							histo[ii] = histo_push( histo[ii], (int)(count[i][j]) );
							
						}
					}
				}
			
			}
			
			double[] alpha=new double[100];
			double[] beta=new double[100];
			for (int i=0;i<histo.length;i++){
				double aa=avg(histo[i]);
				double vv=var(histo[i]);
				if(vv<1.01*aa){
					vv=1.01*aa;
				}
				alpha[i]=aa*aa/(vv-aa);
				beta[i]=aa/(vv-aa);
				System.out.println("AB	"+i+"	"+aa+"	"+vv+"	"+alpha[i]+"	"+beta[i]);
				
			}
			
			
			ArrayList<Double> p_10=new ArrayList<Double>();
			for (int i=0;i<counts_10.length;i++){
				for (int j=0;j<counts_10[i].length;j++){
					if(low(chr[i])<=coverage[i][j]&&coverage[i][j]<high(chr[i])){
						if(!Double.isNaN(prediction_10[i][j])){
							p_10.add(prediction_10[i][j]);
						}
					}
					
				}
			}
			Collections.sort(p_10);
			
			double[] intervals_10=new double[99];
			for (int i=1;i<100;i++){
				intervals_10[i-1]=p_10.get((int)(p_10.size()*(double)(i)/100.0));
			}
			
			
			int[][] histo_10=new int[100][1500];
			for (int i=0;i<counts_10.length;i++){
				for (int j=0;j<counts_10[i].length;j++){
					if(low(chr[i])<=coverage[i][j]&&coverage[i][j]<high(chr[i])){
						if(!Double.isNaN(prediction_10[i][j])){
							int ii=index(prediction_10[i][j],intervals_10);
							histo_10[ii] = histo_push( histo_10[ii], (int)(counts_10[i][j]) );
							
						}
					}
				}
			
			}
			
			double[] alpha_10=new double[100];
			double[] beta_10=new double[100];
			for (int i=0;i<histo_10.length;i++){
				
				double aa=avg(histo_10[i]);
				double vv=var(histo_10[i]);
				if(vv<1.01*aa){
					vv=1.01*aa;
				}
				alpha_10[i]=aa*aa/(vv-aa);
				beta_10[i]=aa/(vv-aa);
				
				System.out.println("AB10	"+i+"	"+aa+"	"+vv+"	"+alpha_10[i]+"	"+beta_10[i]);
			}
			
			
			Comparator<double[]> comp=(double[] aa, double[] bb)->{
				return new Double(aa[0]).compareTo(bb[0]);
			};
			
		
			double[][] sum_0=new double[chr.length][];
			boolean[][] skip=new boolean[chr.length][];
			for (int i=0;i<chr.length;i++){
				sum_0[i]=new double[count[i].length];
				skip[i]=new boolean[count[i].length];
				for (int j=0;j<sum_0[i].length;j++){
					sum_0[i][j]=Double.NaN;
				}
			}
			
			for (int i=0;i<prediction.length;i++){
				for (int j=0;j<prediction[i].length;j++){
					if(low(chr[i])<=coverage[i][j*ll/10000]&&coverage[i][j*ll/10000]<high(chr[i])&&!Double.isNaN(prediction[i][j])){
						double pp=log_gamma_poisson_ab((int)(count[i][j]),alpha[index(prediction[i][j],intervals)],beta[index(prediction[i][j],intervals)]);
						sum_0[i][j]=pp;	
					}
				}
			}
			
			ArrayList<double[]> xx=new ArrayList<double[]>();
			for (int i=0;i<sum_0.length;i++){
				for (int j=0;j<sum_0[i].length;j++){
					if(!Double.isNaN(sum_0[i][j])){
						xx.add(new double[]{sum_0[i][j],i,j});
					}
				}
			}
			
			
			
			Collections.sort(xx,comp);
			for (int i=0;i<(int)(xx.size()*0.01);i++){
				skip[(int)(xx.get(i)[1])][(int)(xx.get(i)[2])]=true;
			}
			
			
			double[][] ssum=new double[chr.length][];
			double[][] ssum2=new double[chr.length][];
			for (int i=0;i<chr.length;i++){
				ssum[i]=new double[count[i].length];
				ssum2[i]=new double[count[i].length];
			}
			
			ArrayList<Double> ww=new ArrayList<Double>();
			int space=0;//10000/ll;
			
			for (int kk=1;kk<=15;kk++){
				if(ww.size()>0){
					for (int i=0;i<prediction.length;i++){
						for (int j=0;j<prediction[i].length;j++){
							for (int k=0;k<10;k++){
								if(j-space-10*ww.size()-k+9>=0&&low(chr[i])<=coverage[i][(j-space-10*ww.size()-k+9)*ll/10000]&&coverage[i][(j-space-10*ww.size()-k+9)*ll/10000]<high(chr[i])){
									ssum[i][j]+=ww.get(ww.size()-1)*count[i][j-space-10*ww.size()-k+9];
									ssum2[i][j]+=ww.get(ww.size()-1);
								}	
								if(j+space+10*ww.size()+k-9<coverage[i].length&&low(chr[i])<=coverage[i][(j+space+10*ww.size()+k-9)*ll/10000]&&coverage[i][(j+space+10*ww.size()+k-9)*ll/10000]<high(chr[i])){
									ssum[i][j]+=ww.get(ww.size()-1)*count[i][j+space+10*ww.size()+k-9];
									ssum2[i][j]+=ww.get(ww.size()-1);
								}
							}
							
						}
					}
				}
				
				
				SubthreadX[] threads=new SubthreadX[101];
				for (int i=0;i<threads.length;i++){
					threads[i]=new SubthreadX();
					
					threads[i].ssum=ssum;
					threads[i].ssum2=ssum2;
					threads[i].prediction=prediction;
					threads[i].coverage=coverage;
					threads[i].count=count;
					threads[i].skip=skip;
					threads[i].alpha=alpha;
					threads[i].beta=beta;
					threads[i].intervals=intervals;
					threads[i].space=space;
					threads[i].kk=kk;
					threads[i].ll=1000;
					threads[i].w=(double)(i)/100.0;
					
				}
				execute(threads,30);
				
				double max=-Double.MAX_VALUE;
				double w_max=-1;
				for (int i=0;i<threads.length;i++){
					if(threads[i].sum2>max){
						max=threads[i].sum2;
						w_max=threads[i].w;
					}
				}
				ww.add(w_max);
				System.out.println(kk+"	"+max+"	"+w_max);
				
				
			}	
			
			for (int j=ww.size()-1;j>=0;j--){
				if(ww.get(j)>0){
					break;
				}
				ww.remove(j);
			}
			
			double[][] pp2C=new double[chr.length][];
			for (int i=0;i<chr.length;i++){
				pp2C[i]=new double[prediction[i].length];
				for (int j=0;j<prediction[i].length;j++){
					pp2C[i][j]=Double.NaN;
				}
			}
			
			for (int i=0;i<prediction.length;i++){
				System.out.println(i);
				for (int j=0;j<prediction[i].length;j++){
					//System.out.println(i+"	"+j);
					if(low(chr[i])<=coverage[i][j*ll/10000]&&coverage[i][j*ll/10000]<high(chr[i])){
						if(!Double.isNaN(prediction[i][j])){
					
							double sum1=0;
							double sum2=0;
							for (int kk=1;kk<=ww.size();kk++){
								for (int l=0;l<10;l++){
									if(j-space-10*kk-l+9>=0&&low(chr[i])<=coverage[i][(j-space-10*kk-l+9)*ll/10000]&&coverage[i][(j-space-10*kk-l+9)*ll/10000]<high(chr[i])&&alignability_fine[i][j-space-10*kk-l+9]>0.5){
										sum1+=ww.get(kk-1)*count[i][j-space-10*kk-l+9]/alignability_fine[i][j-space-10*kk-l+9];
										sum2+=ww.get(kk-1);
									}	
									if(j+space+10*kk+l-9<coverage[i].length&&low(chr[i])<=coverage[i][(j+space+10*kk+l-9)*ll/10000]&&coverage[i][(j+space+10*kk+l-9)*ll/10000]<high(chr[i])&&alignability_fine[i][j+space+10*kk+l-9]>0.5){
										sum1+=ww.get(kk-1)*count[i][j+space+10*kk+l-9]/alignability_fine[i][j+space+10*kk+l-9];
										sum2+=ww.get(kk-1);
									}
								}
								
							}

							double pp2A= 1.0;
							double pp2B=1.0;
							if(count[i][j]>0){
								pp2A= 1-cum_gamma_poisson((int)(count[i][j]-1),alpha[index(prediction[i][j],intervals)]+sum1,beta[index(prediction[i][j],intervals)]+sum2);
								if(count[i][j]>1){
									pp2B=1-cum_gamma_poisson((int)(count[i][j]-2),alpha[index(prediction[i][j],intervals)]+sum1,beta[index(prediction[i][j],intervals)]+sum2);
								}
							}
							
							pp2C[i][j]=(pp2B-pp2A)*Math.random()+pp2A;
							
						}
						else{
							pp2C[i][j]=1.0;
						}
					}
				}
			}
	
			double[][] sum_0_10=new double[chr.length][];
			boolean[][] skip_10=new boolean[chr.length][];
			for (int i=0;i<chr.length;i++){
				sum_0_10[i]=new double[counts_10[i].length];
				skip_10[i]=new boolean[counts_10[i].length];
				for (int j=0;j<sum_0_10[i].length;j++){
					sum_0_10[i][j]=Double.NaN;
				}
			}
			
			for (int i=0;i<prediction_10.length;i++){
				for (int j=0;j<prediction_10[i].length;j++){
					if(low(chr[i])<=coverage[i][j]&&coverage[i][j]<high(chr[i])&&!Double.isNaN(prediction_10[i][j])){
						double pp=log_gamma_poisson_ab((int)(counts_10[i][j]),alpha_10[index(prediction_10[i][j],intervals_10)],beta_10[index(prediction_10[i][j],intervals_10)]);
						sum_0_10[i][j]=pp;	
					}
				}
			}
			
			ArrayList<double[]> xx_10=new ArrayList<double[]>();
			for (int i=0;i<sum_0_10.length;i++){
				for (int j=0;j<sum_0_10[i].length;j++){
					if(!Double.isNaN(sum_0_10[i][j])){
						xx_10.add(new double[]{sum_0_10[i][j],i,j});
					}
				}
			}
			
			
			Collections.sort(xx_10,comp);
			for (int i=0;i<(int)(xx_10.size()*0.01);i++){
				skip_10[(int)(xx_10.get(i)[1])][(int)(xx_10.get(i)[2])]=true;
			}
			
			
			double[][] ssum_10=new double[chr.length][];
			double[][] ssum2_10=new double[chr.length][];
			for (int i=0;i<chr.length;i++){
				ssum_10[i]=new double[counts_10[i].length];
				ssum2_10[i]=new double[counts_10[i].length];
			}
			
			ArrayList<Double> ww_10=new ArrayList<Double>();
			int space_10=0;
			for (int kk=1;kk<=15;kk++){

				if(ww_10.size()>0){
					for (int i=0;i<prediction_10.length;i++){
						for (int j=0;j<prediction_10[i].length;j++){
							if(j-space_10-ww_10.size()>=0&&low(chr[i])<=coverage[i][(j-space_10-1*ww_10.size())]&&coverage[i][(j-space_10-1*ww_10.size())]<high(chr[i])){
								ssum_10[i][j]+=ww_10.get(ww_10.size()-1)*counts_10[i][j-space_10-1*ww_10.size()];
								ssum2_10[i][j]+=ww_10.get(ww_10.size()-1);
							}	
							if(j+space_10+ww_10.size()<coverage[i].length&&low(chr[i])<=coverage[i][(j+space_10+1*ww_10.size())]&&coverage[i][(j+space_10+1*ww_10.size())]<high(chr[i])){
								ssum_10[i][j]+=ww_10.get(ww_10.size()-1)*counts_10[i][j+space_10+1*ww_10.size()];
								ssum2_10[i][j]+=ww_10.get(ww_10.size()-1);
							}	
						}
					}
				}
				
				
				SubthreadX_10[] threads=new SubthreadX_10[101];
				for (int i=0;i<threads.length;i++){
					threads[i]=new SubthreadX_10();
					
					threads[i].ssum=ssum_10;
					threads[i].ssum2=ssum2_10;
					threads[i].prediction=prediction_10;
					threads[i].coverage=coverage;
					threads[i].count=counts_10;
					threads[i].skip=skip_10;
					threads[i].alpha=alpha_10;
					threads[i].beta=beta_10;
					threads[i].intervals=intervals_10;
					threads[i].space=space_10;
					threads[i].kk=kk;
				//	threads[i].ll=10000;
					threads[i].w=(double)(i)/100.0;
					
				}
				execute(threads,30);
				
				double max=-Double.MAX_VALUE;
				double w_max=-1;
				for (int i=0;i<threads.length;i++){
					if(threads[i].sum2>max){
						max=threads[i].sum2;
						w_max=threads[i].w;
					}
				}
				ww_10.add(w_max);
				System.out.println(kk+"	"+max+"	"+w_max);
				
				
			}	
			
			
			
			for (int j=ww_10.size()-1;j>=0;j--){
				if(ww_10.get(j)>0){
					break;
				}
				ww_10.remove(j);
			}
			
			double[][] pp2_10C=new double[chr.length][];
			for (int i=0;i<chr.length;i++){

				pp2_10C[i]=new double[prediction_10[i].length];
				for (int j=0;j<prediction_10[i].length;j++){
					pp2_10C[i][j]=Double.NaN;
				}
			}
			
			
			
			for (int i=0;i<prediction_10.length;i++){
				for (int j=0;j<prediction_10[i].length;j++){
					if(low(chr[i])<=coverage[i][j]&&coverage[i][j]<high(chr[i])){
						if(!Double.isNaN(prediction_10[i][j])){
							
							double sum1=0;
							double sum2=0;
							for (int k=1;k<=ww_10.size();k++){
								if(j-space_10-k>=0&&low(chr[i])<=coverage[i][(j-space_10-k)]&&coverage[i][(j-space_10-k)]<high(chr[i])&&alignability[i][j-space_10-k]>0.5){
									sum1+=ww_10.get(k-1)*counts_10[i][j-space_10-k]/alignability[i][j-space_10-k];
									sum2+=ww_10.get(k-1);
								}	
								if(j+space_10+k<coverage[i].length&&low(chr[i])<=coverage[i][(j+space_10+k)]&&coverage[i][(j+space_10+k)]<high(chr[i])&&alignability[i][j+space_10+k]>0.5){
									sum1+=ww_10.get(k-1)*counts_10[i][j+space_10+k]/alignability[i][j+space_10+k];
									sum2+=ww_10.get(k-1);
								}
							}
							double pp2_10A=1.0;
							double pp2_10B=1.0;
							if(counts_10[i][j]>0){
								pp2_10A=1-cum_gamma_poisson((int)(counts_10[i][j]-1),alpha_10[index(prediction_10[i][j],intervals_10)]+sum1,beta_10[index(prediction_10[i][j],intervals_10)]+sum2);
								if(counts_10[i][j]>1){
									pp2_10B=1-cum_gamma_poisson((int)(counts_10[i][j]-2),alpha_10[index(prediction_10[i][j],intervals_10)]+sum1,beta_10[index(prediction_10[i][j],intervals_10)]+sum2);
								}
							}
							
							pp2_10C[i][j]=(pp2_10B-pp2_10A)*Math.random()+pp2_10A;
							
							if(Double.isNaN(pp2_10C[i][j])){
								System.out.println(chr[i]+"	"+(j*10000));
								System.out.println("pp2_10A	"+pp2_10A);
								System.out.println("pp2_10B	"+pp2_10B);
								System.out.println("counts_10	"+counts_10[i][j]);
								System.out.println("alpha_10	"+alpha_10[index(prediction_10[i][j],intervals_10)]);
								System.out.println("beta_10	"+beta_10[index(prediction_10[i][j],intervals_10)]);
								System.out.println("sum1	"+sum1);
								System.out.println("sum2	"+sum2);
								System.out.println("prediction_10	"+prediction_10[i][j]);
							}
							
						}
						else{
							pp2_10C[i][j]=1.0;
						}
					}
				}
			}
	
			
			for (int i=0;i<chr.length;i++){
				p_result[i]=new double[1+(chr_length[i]-shift_mut)/10000][2];
				for (int j=0;j<1+(chr_length[i]-shift_mut)/10000;j++){
					
					if(low(chr[i])<=coverage[i][j]&&coverage[i][j]<high(chr[i])){
						double min=1;
						for (int k=0;k<10;k++){
							if(pp2C[i][j*10+k]<min){
								min=pp2C[i][j*10+k];
							}
						}
						
						double p_min=(1-Math.pow(1-min,10));
						
						p_result[i][j][0]=Math.max(0, p_min);
						p_result[i][j][1]=Math.max(0, pp2_10C[i][j]);
					}
					else{
						p_result[i][j][0]=1.0;
						p_result[i][j][1]=1.0;
					}
				}
			}
			
			
			double[][][] c=new double[prediction.length][][];
			for (int i=0;i<prediction.length;i++){
				c[i]=new double[prediction[i].length][3];
				System.out.println(i);
				for (int j=0;j<prediction[i].length;j++){
					//System.out.println(i+"	"+j);
					if(low(chr[i])<=coverage[i][j*ll/10000]&&coverage[i][j*ll/10000]<high(chr[i])){
						if(!Double.isNaN(prediction[i][j])){
					
							double sum1=0;
							double sum2=0;
							for (int kk=1;kk<=ww.size();kk++){
								for (int l=0;l<10;l++){
									if(j-space-10*kk-l+9>=0&&low(chr[i])<=coverage[i][(j-space-10*kk-l+9)*ll/10000]&&coverage[i][(j-space-10*kk-l+9)*ll/10000]<high(chr[i])&&alignability_fine[i][j-space-10*kk-l+9]>0.5){
										sum1+=ww.get(kk-1)*count[i][j-space-10*kk-l+9]/alignability_fine[i][j-space-10*kk-l+9];
										sum2+=ww.get(kk-1);
									}	
									if(j+space+10*kk+l-9<coverage[i].length&&low(chr[i])<=coverage[i][(j+space+10*kk+l-9)*ll/10000]&&coverage[i][(j+space+10*kk+l-9)*ll/10000]<high(chr[i])&&alignability_fine[i][j+space+10*kk+l-9]>0.5){
										sum1+=ww.get(kk-1)*count[i][j+space+10*kk+l-9]/alignability_fine[i][j+space+10*kk+l-9];
										sum2+=ww.get(kk-1);
									}
								}
								
							}
							
							c[i][j]=new double[]{count[i][j],alpha[index(prediction[i][j],intervals)]+sum1,beta[index(prediction[i][j],intervals)]+sum2};
						}
						else{
							
						}
					}
				}
			}
			
			
			double[][][] c_10=new double[prediction_10.length][][];
			for (int i=0;i<prediction_10.length;i++){
				c_10[i]=new double[prediction_10[i].length][3];
				for (int j=0;j<prediction_10[i].length;j++){
					if(low(chr[i])<=coverage[i][j]&&coverage[i][j]<high(chr[i])){
						if(!Double.isNaN(prediction_10[i][j])){
							
							double sum1=0;
							double sum2=0;
							for (int k=1;k<=ww_10.size();k++){
								if(j-space_10-k>=0&&low(chr[i])<=coverage[i][(j-space_10-k)]&&coverage[i][(j-space_10-k)]<high(chr[i])&&alignability[i][j-space_10-k]>0.5){
									sum1+=ww_10.get(k-1)*counts_10[i][j-space_10-k]/alignability[i][j-space_10-k];
									sum2+=ww_10.get(k-1);
								}	
								if(j+space_10+k<coverage[i].length&&low(chr[i])<=coverage[i][(j+space_10+k)]&&coverage[i][(j+space_10+k)]<high(chr[i])&&alignability[i][j+space_10+k]>0.5){
									sum1+=ww_10.get(k-1)*counts_10[i][j+space_10+k]/alignability[i][j+space_10+k];
									sum2+=ww_10.get(k-1);
								}
							}
							
							c_10[i][j]=new double[]{counts_10[i][j],alpha_10[index(prediction_10[i][j],intervals_10)]+sum1,beta_10[index(prediction_10[i][j],intervals_10)]+sum2};
							
						
						}
						
					}
				}
			}
			
			return new double[][][][]{p_result,c,c_10};
			
		}
		
	}
	
	//execute multiple Threads in parallel
	public static void execute(SubthreadX[] threads, int no_cpu){
		boolean all_done=false;
		while(!all_done){
			all_done=true;
			int n1=0;
			int n2=0;		
			for (int i=0;i<threads.length;i++){
				if(threads[i].status==0){
					n1++;
				}
				if(threads[i].status==1){
					n2++;
				}
				if(threads[i].status!=2){
					all_done=false;
				}
			}
			if(n1>0&&n2<no_cpu){
				for (int i=0;i<threads.length;i++){
					if(threads[i].status==0){
						threads[i].status=1;
						threads[i].start();
						n1--;
						n2++;
						if(n1==0||n2>=no_cpu){
							break;
						}
					}
				}
			}
			try{
				Thread.sleep(10);
			}
			catch(java.lang.InterruptedException e){
			}
		}
	}
	
	//execute multiple Threads in parallel
	public static void execute(ThreadTestFactor[][] threads, int no_cpu){
		boolean all_done=false;
		while(!all_done){
			all_done=true;
			int n1=0;
			int n2=0;		
			for (int i=0;i<threads.length;i++){
				for (int j=0;j<threads[i].length;j++){
					if(threads[i][j].status==0){
						n1++;
					}
					if(threads[i][j].status==1){
						n2++;
					}
					if(threads[i][j].status!=2){
						all_done=false;
					}
				}
				
			}
			if(n1>0&&n2<no_cpu){
				for (int i=0;i<threads.length;i++){
					for (int j=0;j<threads[i].length;j++){
						if(threads[i][j].status==0){
							threads[i][j].status=1;
							threads[i][j].start();
							n1--;
							n2++;
							if(n1==0||n2>=no_cpu){
								break;
							}
						}
					}
					
				}
			}
			try{
				Thread.sleep(10);
			}
			catch(java.lang.InterruptedException e){
			}
		}
	}
	
	//execute multiple Threads in parallel
	public static void execute(SubthreadX_10[] threads, int no_cpu){
		boolean all_done=false;
		while(!all_done){
			all_done=true;
			int n1=0;
			int n2=0;		
			for (int i=0;i<threads.length;i++){
				if(threads[i].status==0){
					n1++;
				}
				if(threads[i].status==1){
					n2++;
				}
				if(threads[i].status!=2){
					all_done=false;
				}
			}
			if(n1>0&&n2<no_cpu){
				for (int i=0;i<threads.length;i++){
					if(threads[i].status==0){
						threads[i].status=1;
						threads[i].start();
						n1--;
						n2++;
						if(n1==0||n2>=no_cpu){
							break;
						}
					}
				}
			}
			try{
				Thread.sleep(10);
			}
			catch(java.lang.InterruptedException e){
			}
		}
		
		
	}
	
	
	//Subthread to optimize the local average weights of similarity-based statistics
	private static class SubthreadX extends Thread{
		double[][] ssum=new double[chr.length][];
		double[][] ssum2=new double[chr.length][];
		double[][] prediction=new double[0][];
		double[][] coverage=new double[0][];
		double[][] count=new double[0][];
		boolean[][] skip=new boolean[0][];
		double[] alpha=new double[0];
		double[] beta=new double[0];
		double[] intervals=new double[0];
		int ll=-1;
		int space=-1;
		int kk=-1;
		double w=0;
		
		double sum2=0;
		volatile int status=0;
		
		public void run(){
			status=1;
			for (int i=0;i<prediction.length;i++){
				if(i!=0){
					continue;		
				}
				for (int j=0;j<prediction[i].length;j++){
					if(low(chr[i])<=coverage[i][j*ll/10000]&&coverage[i][j*ll/10000]<high(chr[i])&&!Double.isNaN(prediction[i][j])){
						double a=0;
						double b=0;
						for (int k=0;k<10;k++){
							if(j-space-10*kk-k+9>=0&&(j+space+10*kk+k-9)*ll/10000<coverage[i].length&&low(chr[i])<=coverage[i][(j-space-10*kk-k+9)*ll/10000]&&coverage[i][(j-space-10*kk-k+9)*ll/10000]<high(chr[i])&&low(chr[i])<=coverage[i][(j+space+10*kk+k-9)*ll/10000]&&coverage[i][(j+space+10*kk+k-9)*ll/10000]<high(chr[i])){
								a+=+w*count[i][j-space-10*kk-k+9]+w*count[i][j+space+10*kk+k-9];
								b+=2*w;
							}
						}
						if(!skip[i][j]){
							double pp=log_gamma_poisson_ab((int)(count[i][j]),alpha[index(prediction[i][j],intervals)]+a+ssum[i][j],beta[index(prediction[i][j],intervals)]+b+ssum2[i][j]);
							if(!Double.isNaN(pp)){
								sum2+=pp;
							}
								
						}
					}
				}
			}
			status=2;
		}
		
	}
	
	//Subthread to optimize the local average weights of similarity-based statistics
	private static class SubthreadX_10 extends Thread{
		double[][] ssum=new double[chr.length][];
		double[][] ssum2=new double[chr.length][];
		double[][] prediction=new double[0][];
		double[][] coverage=new double[0][];
		double[][] count=new double[0][];
		boolean[][] skip=new boolean[0][];
		double[] alpha=new double[0];
		double[] beta=new double[0];
		double[] intervals=new double[0];
		int space=-1;
		int kk=-1;
		double w=0;
		
		double sum2=0;
		volatile int status=0;
		
		public void run(){
			status=1;
			for (int i=0;i<prediction.length;i++){
				if(i!=0){
					continue;		
				}
				for (int j=0;j<prediction[i].length;j++){
					if(low(chr[i])<=coverage[i][j]&&coverage[i][j]<high(chr[i])&&!Double.isNaN(prediction[i][j])){
						double a=0;
						double b=0;
						if(j-space-kk>=0&&j+space+kk<coverage[i].length&&low(chr[i])<=coverage[i][(j-space-kk)]&&coverage[i][(j-space-kk)]<high(chr[i])&&low(chr[i])<=coverage[i][(j+space+kk)]&&coverage[i][(j+space+kk)]<high(chr[i])){
							a+=+w*count[i][j-space-kk]+w*count[i][j+space+kk];
							b+=2*w;
						}
							
						
						if(!skip[i][j]){
							double pp=log_gamma_poisson_ab((int)(count[i][j]),alpha[index(prediction[i][j],intervals)]+a+ssum[i][j],beta[index(prediction[i][j],intervals)]+b+ssum2[i][j]);
							if(!Double.isNaN(pp)){
								sum2+=pp;
							}
								
						}
					}
				}
			}
			status=2;
		}
		
	}
	
	//probability density function of the Gamma-Poisson distribution
	public static double log_gamma_poisson_ab(int k,double alpha, double beta) {
		return Gamma.logGamma(k+alpha)-Gamma.logGamma(k+1)-Gamma.logGamma(alpha)+Math.log(beta/(beta+1))*alpha+Math.log(1/(beta+1))*k;
	}
	
	//cumulative density function of the Gamma-Poisson distribution
	public static double cum_gamma_poisson(int k,double alpha, double beta) {
		double sum=0;
		for(int i=0;i<=k;i++){
			sum+=Math.exp(log_gamma_poisson_ab(i,alpha,beta));
		}
		return sum;
	}
	
	
	public static int index(double x, double[] intervals){
		if(x<intervals[0]){
			return 0;
		}
		if(x>=intervals[intervals.length-1]){
			return intervals.length;
		}
	
		for (int i=1;i<intervals.length;i++){
			if(intervals[i-1]<=x&&x<intervals[i]){
				return i;
			}
		}
		return -1;
	}

	//add a value to a histogram, extending it if necessary
	public static int[] histo_push(int[] histo, int x){
		int len = histo.length;
		while (!(x < len))
			len += len / 2;
		if (histo.length < len)
			histo = java.util.Arrays.copyOf(histo, len);

		++histo[x];
		return histo;
	}
	
	//average of a count-based distribution function
	public static double avg(int[] histo){
		double n=0;
		double avg=0;
		for (int i=0;i<histo.length;i++){
			avg+=histo[i]*i;
			n+=histo[i];
		}
		if(n>0){
			avg/=n;
		}
		return avg;
	}
	
	//variance of a count-based distribution function
	public static double var(int[] histo){
		double n=0;
		double avg=0;
		for (int i=0;i<histo.length;i++){
			avg+=histo[i]*i;
			n+=histo[i];
		}
		if(n>0){
			avg/=n;
		}
		double var=0;
		for (int i=0;i<histo.length;i++){
			var+=histo[i]*(i-avg)*(i-avg);
		}
		if(n>0){
			var/=n;
		}
		return var;
	}
	
	//cummulative distribution function of the Gamma distribution
	public static double cum_gamma(double x, double alpha , double beta){
		{
			return Gamma.regularizedGammaP(alpha,beta*x);
		}
	}
	
	//density function of the Gamma distribution
	public static double gamma(double x, double alpha , double beta){
		return Math.log(beta)*alpha-Gamma.logGamma(alpha)+Math.log(x)*(alpha-1)-beta*x;
	}
	
	public static void add(int[] x, int[] y){
		for (int i=0;i<x.length;i++){
			x[i]+=y[i];
		}
		
	}
	
	//optimize the coefficients to model the variance of cluster scores based on their distribution average.
	//factor1 establishes a linear link between average and variance, factor2 a quadratic link
	public static double[] max_factor(double[][] clumps_combi, double[][] avg_clumps_combi, double[][] coverage) throws java.io.IOException {
		{
			ThreadTestFactor[][] threads_factor=new ThreadTestFactor[10][50];
			for (int i=0;i<threads_factor.length;i++){
				for (int j=0;j<threads_factor[i].length;j++){
					threads_factor[i][j]=new ThreadTestFactor();
					threads_factor[i][j].avg_clumps_combi=avg_clumps_combi;
					threads_factor[i][j].clumps_combi=clumps_combi;
					threads_factor[i][j].factor1=(double)(i+1)*0.1;
					threads_factor[i][j].factor2=(double)(j+1)*0.001;
					threads_factor[i][j].coverage=coverage;
					//threads_factor[i][j].start();
				}
				
			}
			
			
			
			execute(threads_factor,30);
			
			double sum_max=-Double.MAX_VALUE;
			double factor_max1=0;//0.65;
			double factor_max2=0;//0.65;
			for (int i=0;i<threads_factor.length;i++){
				for (int j=0;j<threads_factor[i].length;j++){
					if(threads_factor[i][j].sum>sum_max){
						sum_max=threads_factor[i][j].sum;
						factor_max1=threads_factor[i][j].factor1;
						factor_max2=threads_factor[i][j].factor2;
						
					}
					//System.out.println(threads_factor[i][j].factor1+"	"+threads_factor[i][j].factor2+"	"+threads_factor[i][j].sum);
					
				}
				//System.out.println(threads_factor[i].factor+"	"+threads_factor[i].sum);
				
			}
			System.out.println("Max Factor Step 1	"+factor_max1+"	"+factor_max2);
			
			threads_factor=new ThreadTestFactor[21][21];
			for (int i=0;i<threads_factor.length;i++){
				for (int j=0;j<threads_factor[i].length;j++){
					threads_factor[i][j]=new ThreadTestFactor();
					threads_factor[i][j].avg_clumps_combi=avg_clumps_combi;
					threads_factor[i][j].clumps_combi=clumps_combi;
					threads_factor[i][j].factor1=factor_max1-0.1+(double)(i)*0.01;
					threads_factor[i][j].factor2=factor_max2-0.001+(double)(j)*0.0001;;
					threads_factor[i][j].coverage=coverage;
					//threads_factor[i][j].start();
				}
			}
			execute(threads_factor,30);
				
			
			
			sum_max=-Double.MAX_VALUE;
			//factor_max1=0.65;
			//factor_max2=0.65;
			for (int i=0;i<threads_factor.length;i++){
				for (int j=0;j<threads_factor[i].length;j++){
					if(threads_factor[i][j].sum>sum_max){
						sum_max=threads_factor[i][j].sum;
						factor_max1=threads_factor[i][j].factor1;
						factor_max2=threads_factor[i][j].factor2;
					}
					//System.out.println(threads_factor[i][j].factor1+"	"+threads_factor[i][j].factor2+"	"+threads_factor[i][j].sum);
					
				}
				//System.out.println(threads_factor[i].factor+"	"+threads_factor[i].sum);
				
			}
			System.out.println("Max Factor Step 2	"+factor_max1+"	"+factor_max2);
			
			//System.exit(0);
			return new double[]{factor_max1,factor_max2};
		}
		
		
		
	}
	
	//Subthread to determine the distance between mutations (all mutations) to optimize weights in the cluster score
	private static class SubthreadClumpsDistance extends Thread{
		
		double[][] coverage=null;
		volatile int status=0;
		int i=-1;
		ArrayList<Mutation>[][] mutations=null;
		Hashtable<Integer,Integer> table_skip=null;
		int[] observed=new int[10000];
		int[] expected=new int[10000];
		
		public void run(){
			status=1;
			ThreadLocalRandom random=ThreadLocalRandom.current();
			
			{
				
				for (int j=0;j<mutations[i].length;j++){
					if(table_skip.get(j)!=null){
						//System.out.println("Skip "+chr[i]+"	"+j);
						continue;
					}
					if(low(chr[i])<=coverage[i][j]&&coverage[i][j]<high(chr[i])){
						add(observed,clumps3_mut_distance(mutations[i][j]));
						int[] nn_1=n_combi(mutations[i][j]);
						for (int k=0;k<10;k++){
							ArrayList<ArrayList<Integer>> x=new ArrayList<ArrayList<Integer>>();
							for (int l=0;l<nn_1.length;l++){
								x.add(new ArrayList<Integer>());
								for (int ll=0;ll<nn_1[l];ll++){
									x.get(l).add(select(interval_align[i][j],random));
									
								}
							}
							add(expected,clumps3_distance(x));
						}
					}
				}
			}
			System.out.println("End "+i);
			status=2;
		}
		
	}
	
	//Subthread to determine the distance between mutations (indels only) to optimize weights in the cluster score
	private static class SubthreadClumpsDistance_indel extends Thread{
		double[][] coverage=null;
		volatile int status=0;
		int i=-1;
		ArrayList<Mutation>[][] mutations=null;
		Hashtable<Integer,Integer> table_skip=null;
		int[] observed=new int[10000];
		int[] expected=new int[10000];
		
		public void run(){
			status=1;
			ThreadLocalRandom random=ThreadLocalRandom.current();
			
			{
				
				for (int j=0;j<mutations[i].length;j++){
					if(table_skip.get(j)!=null){
						//System.out.println("Skip "+chr[i]+"	"+j);
						continue;
					}
					if(low(chr[i])<=coverage[i][j]&&coverage[i][j]<high(chr[i])){
						add(observed,clumps3_mut_distance_indel(mutations[i][j]));
						int[] nn_1=n_combi_indel(mutations[i][j]);
						for (int k=0;k<10;k++){
							ArrayList<ArrayList<Integer>> x=new ArrayList<ArrayList<Integer>>();
							for (int l=0;l<nn_1.length;l++){
								x.add(new ArrayList<Integer>());
								for (int ll=0;ll<nn_1[l];ll++){
									x.get(l).add(select(interval_align[i][j],random));
									
								}
							}
							add(expected,clumps3_distance(x));
						}
					}
				}
			}
			System.out.println("End "+i);
			status=2;
		}
		
	}
	
	//Subthread to optimize factors to estimate the variance of the cluster scores based on their distribution average
	private static class ThreadTestFactor extends Thread{
		double[][] avg_clumps_combi=null;
		double[][] clumps_combi=null;
		double[][] coverage=null;
		double factor1=0;
		double factor2=0;
		double sum=0;
		
		int status=0;
		public void run(){
			status=1;
			if(factor1<=0||factor2<=0){
				sum=-Double.MAX_VALUE;
				status=2;
				return;
			}
			{
				for (int i=0;i<clumps_combi.length;i++){
					for (int j=0;j<clumps_combi[i].length;j++){
						if(low(chr[i])<=coverage[i][j]&&coverage[i][j]<high(chr[i])){
							if(alignability[i][j]>0.5&&avg_clumps_combi[i][j]>0.1&&clumps_combi[i][j]<4*avg_clumps_combi[i][j]){
								double avg_c=avg_clumps_combi[i][j];
								double var_c=avg_clumps_combi[i][j]*factor1+avg_clumps_combi[i][j]*avg_clumps_combi[i][j]*factor2;
								double alpha=avg_c*avg_c/var_c;
								double beta=avg_c/var_c;
								if(clumps_combi[i][j]==0||clumps_combi[i][j]==0){
									
								}
								else{
									sum+=gamma(clumps_combi[i][j],alpha,beta);	
								}
							}
							
							
						}
						
						
						
					}
				}
			}
			status=2;
		}
	}
	
	//Subthread to determine the expected and observed clustering score for each intervall (all mutations)
	private static class SubthreadClumpsCombi extends Thread{
		
		double[][] coverage=null;
		volatile int status=0;
		int i=-1;
		double[] avg_clumps=null;
		double[] clumps=null;
		double[] factor_clumps=null;
		ArrayList<Mutation>[][] mutations=null;
		
		public void run(){
			status=1;
			ThreadLocalRandom random=ThreadLocalRandom.current();
			
			{
				
				avg_clumps=new double[1+(chr_length[i]-shift_mut)/10000];
				clumps=new double[1+(chr_length[i]-shift_mut)/10000];
				for (int j=0;j<mutations[i].length;j++){
					if(low(chr[i])<=coverage[i][j]&&coverage[i][j]<high(chr[i])){
						
						double c_1XX=clumps3_mut_combi(mutations[i][j],factor_clumps);//,factor
						double avg_1XXXX=0;
						if(c_1XX>0){
							int[] nn_1=n_combi(mutations[i][j]);
							for (int k=0;k<100;k++){
								ArrayList<ArrayList<Integer>> x=new ArrayList<ArrayList<Integer>>();
								for (int l=0;l<nn_1.length;l++){
									x.add(new ArrayList<Integer>());
									for (int ll=0;ll<nn_1[l];ll++){
										x.get(l).add(select(interval_align[i][j],random));
										
									}
								}
								avg_1XXXX+=clumps3(x);//,factor
							}
							avg_1XXXX/=100.0;
						}
						
						
						avg_clumps[j]=avg_1XXXX;
						clumps[j]=c_1XX;
					
					}
				}
			}
			System.out.println("End "+i);
			status=2;
		}
		
	}
	
	//Subthread to determine the expected and observed clustering score for each intervall (indels only)
	private static class SubthreadClumpsCombi_indel extends Thread{
		
		double[][] coverage=null;
		volatile int status=0;
		int i=-1;
		double[] avg_clumps=null;
		double[] clumps=null;
		double[] factor_clumps=null;
		ArrayList<Mutation>[][] mutations=null;
		
		public void run(){
			status=1;
			ThreadLocalRandom random=ThreadLocalRandom.current();
			
			{
				
				avg_clumps=new double[1+(chr_length[i]-shift_mut)/10000];
				clumps=new double[1+(chr_length[i]-shift_mut)/10000];
				for (int j=0;j<mutations[i].length;j++){
					if(low(chr[i])<=coverage[i][j]&&coverage[i][j]<high(chr[i])){
						
						double c_1XX=clumps3_mut_combi_indel(mutations[i][j],factor_clumps);//,factor
						double avg_1XXXX=0;
						if(c_1XX>0){
							int[] nn_1=n_combi_indel(mutations[i][j]);
							for (int k=0;k<100;k++){
								ArrayList<ArrayList<Integer>> x=new ArrayList<ArrayList<Integer>>();
								for (int l=0;l<nn_1.length;l++){
									x.add(new ArrayList<Integer>());
									for (int ll=0;ll<nn_1[l];ll++){
										x.get(l).add(select(interval_align[i][j],random));
										
									}
								}
								avg_1XXXX+=clumps3(x);//,factor
							}
							avg_1XXXX/=100.0;
						}
						
						
						avg_clumps[j]=avg_1XXXX;
						clumps[j]=c_1XX;
					
					}
				}
			}
			System.out.println("End "+i);
			status=2;
		}
		
	}
	
	//count the pairwise distance between mutations
	public static int[] clumps3_distance(ArrayList<ArrayList<Integer>> pos){//, double[] factor
		int[] histo=new int[10000];
		double gamma=Math.log(0.5)/100.0;
		if(pos.size()<=1){
			return histo;
		}
		
		for (int i=0;i<pos.size()-1;i++){
			for (int j=i+1;j<pos.size();j++){
				double d=dist(pos.get(i),pos.get(j));
				if(d<histo.length){
					histo[(int)(d)]++;
					
				}
			}
		}
		return histo;
	}
	
	//count the pairwise distance between mutations
	public static int[] clumps3_mut_distance(ArrayList<Mutation> mutations){//ArrayList<Integer> pos, ArrayList<Integer> donors, double[] factor
		if(mutations.size()<=1){
			return new int[10000];
		}
		
		ArrayList<ArrayList<Integer>> pos_clusters=new ArrayList<ArrayList<Integer>>();
		Hashtable<String,Integer> table=new Hashtable<String,Integer>();
		for (int i=0;i<mutations.size();i++){
			if(mutations.get(i).group==0){//||mutations.get(i).group==1
				Integer ii=table.get(mutations.get(i).donor);
				if(ii==null){
					ii=pos_clusters.size();
					table.put(mutations.get(i).donor, pos_clusters.size());
					pos_clusters.add(new ArrayList<Integer>());
				}
				pos_clusters.get(ii).add(mutations.get(i).pos);
			}
			
		}
		return clumps3_distance(pos_clusters);//,factor
				
	}
	
	//count the pairwise distance between mutations (indels only)
	public static int[] clumps3_mut_distance_indel(ArrayList<Mutation> mutations){//ArrayList<Integer> pos, ArrayList<Integer> donors, double[] factor
		if(mutations.size()<=1){
			return new int[10000];
		}
		
		ArrayList<ArrayList<Integer>> pos_clusters=new ArrayList<ArrayList<Integer>>();
		Hashtable<String,Integer> table=new Hashtable<String,Integer>();
		for (int i=0;i<mutations.size();i++){
			if(mutations.get(i).ref.length()!=1||mutations.get(i).alt.length()!=1){
				if(mutations.get(i).group==0){//||mutations.get(i).group==1
					Integer ii=table.get(mutations.get(i).donor);
					if(ii==null){
						ii=pos_clusters.size();
						table.put(mutations.get(i).donor, pos_clusters.size());
						pos_clusters.add(new ArrayList<Integer>());
					}
					pos_clusters.get(ii).add(mutations.get(i).pos);
				}
			}	
		}
		return clumps3_distance(pos_clusters);//,factor
				
	}
	
	//clustering score of mutations
	public static double clumps3(ArrayList<ArrayList<Integer>> pos){//, double[] factor
		double gamma=Math.log(0.5)/100.0;
		if(pos.size()<=1){
			return 0;
		}
		
		double sum=0;
		for (int i=0;i<pos.size()-1;i++){
			for (int j=i+1;j<pos.size();j++){
				double d=dist(pos.get(i),pos.get(j));
				if(d<Double.MAX_VALUE){
					sum+=Math.exp(gamma*d);	
					
				}
			}
		}
		return sum;
	}
	
	
	//clustering score of mutations (weighted version)
	public static double clumps3(ArrayList<ArrayList<Integer>> pos, double[] factor_clumps){//, double[] factor
		double gamma=Math.log(0.5)/100.0;
		if(pos.size()<=1){
			return 0;
		}
		
		double sum=0;
		for (int i=0;i<pos.size()-1;i++){
			for (int j=i+1;j<pos.size();j++){
				double d=dist(pos.get(i),pos.get(j));
				if(d<Double.MAX_VALUE){
					sum+=Math.exp(gamma*d)/factor_clumps[Math.min(factor_clumps.length-1, (int)(d))];//*factor(d,factor)//Math.abs(pos.get(i)-pos.get(j))	
					
				}
			}
		}
		return sum;
	}
	
	//clustering score of mutations
	public static double clumps3_mut(ArrayList<Mutation> mutations){//ArrayList<Integer> pos, ArrayList<Integer> donors, double[] factor
		if(mutations.size()<=1){
			return 0;
		}
		
		ArrayList<ArrayList<Integer>> pos_clusters=new ArrayList<ArrayList<Integer>>();
		Hashtable<String,Integer> table=new Hashtable<String,Integer>();
		for (int i=0;i<mutations.size();i++){
			if(mutations.get(i).group==0){//||mutations.get(i).group==1
				Integer ii=table.get(mutations.get(i).donor);
				if(ii==null){
					ii=pos_clusters.size();
					table.put(mutations.get(i).donor, pos_clusters.size());
					pos_clusters.add(new ArrayList<Integer>());
				}
				pos_clusters.get(ii).add(mutations.get(i).pos);
			}
			
		}
		return clumps3(pos_clusters);//,factor
				
	}
	
	//clustering score of mutations (weighted version)
	public static double clumps3_mut_combi(ArrayList<Mutation> mutations, double[] factor_clumps){
		if(mutations.size()<=1){
			return 0;
		}
		
		ArrayList<ArrayList<Integer>> pos_clusters=new ArrayList<ArrayList<Integer>>();
		Hashtable<String,Integer> table=new Hashtable<String,Integer>();
		for (int i=0;i<mutations.size();i++){
			if(mutations.get(i).group==0){//||mutations.get(i).group==1
				Integer ii=table.get(mutations.get(i).donor);
				if(ii==null){
					ii=pos_clusters.size();
					table.put(mutations.get(i).donor, pos_clusters.size());
					pos_clusters.add(new ArrayList<Integer>());
				}
				pos_clusters.get(ii).add(mutations.get(i).pos);
			}
			
		}
		return clumps3(pos_clusters,factor_clumps);//,factor
				
	}
	
	//clustering score of mutations (weighted version, indels only)
	public static double clumps3_mut_combi_indel(ArrayList<Mutation> mutations, double[] factor_clumps){//ArrayList<Integer> pos, ArrayList<Integer> donors, double[] factor
		if(mutations.size()<=1){
			return 0;
		}
		
		ArrayList<ArrayList<Integer>> pos_clusters=new ArrayList<ArrayList<Integer>>();
		Hashtable<String,Integer> table=new Hashtable<String,Integer>();
		for (int i=0;i<mutations.size();i++){
			if(mutations.get(i).ref.length()!=1||mutations.get(i).alt.length()!=1){
				if(mutations.get(i).group==0){//||mutations.get(i).group==1
					Integer ii=table.get(mutations.get(i).donor);
					if(ii==null){
						ii=pos_clusters.size();
						table.put(mutations.get(i).donor, pos_clusters.size());
						pos_clusters.add(new ArrayList<Integer>());
					}
					pos_clusters.get(ii).add(mutations.get(i).pos);
				}
			}
		}
		return clumps3(pos_clusters,factor_clumps);//,factor
				
	}
	
	//count number of mutations per sample in a given interval
	public static int[] n_combi (ArrayList<Mutation> mutations){
		ArrayList<Integer> count=new ArrayList<Integer>();
		Hashtable<String,Integer> table=new Hashtable<String,Integer>();
		for (int i=0;i<mutations.size();i++){
			if(mutations.get(i).group==0){//||mutations.get(i).group==1
				Integer ii=table.get(mutations.get(i).donor);
				if(ii==null){
					ii=count.size();
					table.put(mutations.get(i).donor, count.size());
					count.add(0);
				}
				count.set(ii,count.get(ii)+1);
			}
		}
		
		int[] count2=new int[mutations.size()];
		for (int i=0;i<count.size();i++){
			count2[i]=count.get(i);
		}
		return count2;
	}
	
	//count number of mutations per sample in a given interval (indels only)
	public static int[] n_combi_indel (ArrayList<Mutation> mutations){
		ArrayList<Integer> count=new ArrayList<Integer>();
		Hashtable<String,Integer> table=new Hashtable<String,Integer>();
		for (int i=0;i<mutations.size();i++){
			if(mutations.get(i).ref.length()!=1||mutations.get(i).alt.length()!=1){
				if(mutations.get(i).group==0){//||mutations.get(i).group==1
					Integer ii=table.get(mutations.get(i).donor);
					if(ii==null){
						ii=count.size();
						table.put(mutations.get(i).donor, count.size());
						count.add(0);
					}
					count.set(ii,count.get(ii)+1);
				}
			}
			
		}
		
		int[] count2=new int[mutations.size()];
		for (int i=0;i<count.size();i++){
			count2[i]=count.get(i);
		}
		return count2;
	}
	
	//function for simulation of positions of mutations
	public static int select(ArrayList<int[]> interval, ThreadLocalRandom random){
		int l=0;
		for (int i=0;i<interval.size();i++){
			l+=interval.get(i)[1]-interval.get(i)[0];
		}
		
		int pos=-1;
		int attempt=0;		
		while(pos==-1&&attempt<20){
			int r=(int)(random.nextDouble()*l);
			pos=-1;
			int ll=0;
			for (int i=0;i<interval.size();i++){
				if(ll<=r&&r<ll+interval.get(i)[1]-interval.get(i)[0]){
					pos=(int)(random.nextDouble()*(interval.get(i)[1]-interval.get(i)[0])+interval.get(i)[0]);
					break;
				}
				ll+=interval.get(i)[1]-interval.get(i)[0];
			}
			attempt++;
		}
		
		return pos;
	}
	
	//minimum distance of mutations between two samples
	public static double dist(ArrayList<Integer> a, ArrayList<Integer> b){
		double min=Double.MAX_VALUE;
		for (int i=0;i<a.size();i++){
			for (int j=0;j<b.size();j++){
				if(Math.abs(a.get(i)-b.get(j))<min){
					
						min=Math.abs(a.get(i)-b.get(j));
					
					
				}
			}
		}
		return min;
	}
	
	//read coverage files
	public static double[][] read_coverage() throws java.io.IOException {
		double[][] coverage=new double[chr.length][];
		{
			double[][] coverage_n=new double[chr.length][];
			for (int i=0;i<chr.length;i++){
				coverage[i]=new double[1+(chr_length[i]-shift_mut)/10000];
				coverage_n[i]=new double[1+(chr_length[i]-shift_mut)/10000];
			}
			
			java.io.InputStream in=ZipOverlay.fileInputStream(file_coverage);
			BufferedReader input= new BufferedReader(new InputStreamReader(ZipFilter.filterInputStream(in)));
			
			String s="";
			while((s=input.readLine())!=null){
				String[] t=s.split("	");
				if(index(t[0],chr)==-1){
					continue;
				}
				for (int k=(Integer.parseInt(t[1])-shift_mut)/10000;k<Math.min(chr_length[index(t[0],chr)]-shift_mut, Integer.parseInt(t[1])-shift_mut+10000)/10000;k++){
					if(k>=0){
						coverage[index(t[0],chr)][k]+=Double.parseDouble(t[2]);
						coverage_n[index(t[0],chr)][k]++;
					}
				
				}
			}
			input.close();
			
			for (int i=0;i<coverage.length;i++){
				for (int j=0;j<coverage[i].length;j++){
					if(coverage_n[i][j]>0){
						coverage[i][j]/=coverage_n[i][j];
					}
					else{
						coverage[i][j]=Double.NaN;
					}
				}
			}
		}
		return coverage;
	}
	
	
	//class of Mutation with quality annotations
	private static class Mutation{
		int pos=-1;
		String ref="";
		String alt="";
		int index_donor=-1;
		boolean coding=false;
		String donor="";
		
		int group=-1;
	//	double[][] ratio=null;
		boolean msi=false;
		boolean msi2=false;
		boolean exclude=false;
		
		public Mutation(int pos, String ref, String alt, String donor){
			this.pos=pos;
			this.ref=ref;
			this.alt=alt;
			this.donor=donor;
		}
		public Mutation copy(int i){
			Mutation m=new Mutation(this.pos,this.ref,this.alt,this.donor);
			m.coding=this.coding;
			m.index_donor=i;
			return m;
		}
		public Mutation copy(){
			Mutation m=new Mutation(this.pos,this.ref,this.alt,this.donor);
			m.coding=this.coding;
			m.index_donor=this.index_donor;
			return m;
		}
		public String ou(){
			return this.pos+"&"+this.ref+"&"+this.alt+"&"+this.donor+"&"+index_donor+"&"+coding;
		}
	}
	
	//class of a mutated Position
	private static class Position{
		int pos=-1;
		String ref="";
		String ref_as="";
		int as_num=-1;
		String[] alt_as=new String[0];
		
		public Position(int pos, String ref, String ref_as, int as_num, String[] alt_as){
			this.pos=pos;
			this.ref=ref;
			this.ref_as=ref_as;
			this.as_num=as_num;
			this.alt_as=alt_as;
		}
	}
	
	//read mutations of one cancer type and exclude low-quality mutations and problematic regions
	public static void read_mutations (String entities) throws java.io.IOException {//ArrayList<Mutation>[][] 
		{
			ArrayList<String> donors=new ArrayList<String>();;
			int a=index(entities,all_entities);
			for (int b=0;b<files_donors[a].length;b++){
				FileInputStream in=new FileInputStream(files_donors[a][b]);
				BufferedReader input= new BufferedReader(new InputStreamReader(ZipFilter.filterInputStream(in)));
				//input.readLine();
				String s="";
				while((s=input.readLine())!=null){
					String[] t=s.split("	");
					donors.add(t[0]);	
				}
				input.close();
			}
			
			
			ArrayList<Mutation>[][] positions=new ArrayList[donors.size()][chr.length];
			
			for (int i=0;i<positions.length;i++){
				for (int j=0;j<chr.length;j++){
					positions[i][j]=new ArrayList<Mutation>();
				}
			}
			
			System.out.println("A");
			SubthreadReadSingle[] threads_read=new SubthreadReadSingle[chr.length];	
			for (int chr_index=0;chr_index<chr.length;chr_index++){
				threads_read[chr_index]=new SubthreadReadSingle();
				threads_read[chr_index].chr_index=chr_index;
				threads_read[chr_index].positions=positions;
				threads_read[chr_index].donors=donors;
				threads_read[chr_index].file_mut_snv=files_mut_snv[a][chr_index];
				threads_read[chr_index].file_mut_indel=files_mut_indel[a][chr_index];
				threads_read[chr_index].start();
			}
			
			boolean all_done=false;
			while(!all_done){
				all_done=true;
				for (int i=0;i<threads_read.length;i++){
					if(threads_read[i].status!=2){
						all_done=false;
					}
				}
				try{
				Thread.sleep(250);
				}
				catch(java.lang.InterruptedException e){
				}
			}
			System.out.println("A");
			
			{
				exclude=new ArrayList[chr.length][];
				for (int i=0;i<chr.length;i++){
					exclude[i]=new ArrayList[1+(chr_length[i]-shift_mut)/10000];
					for (int j=0;j<exclude[i].length;j++){
						exclude[i][j]=new ArrayList<Integer>();
					}
				}
				
				if(entities.equals("Liver")){
					java.io.InputStream in=ZipOverlay.fileInputStream(file_exclude_regions_liver);
					BufferedReader input= new BufferedReader(new InputStreamReader(ZipFilter.filterInputStream(in)));
					String s="";
					while((s=input.readLine())!=null){
						String[] t=s.split("	");
						if(Integer.parseInt(t[1])>=shift_mut){
							exclude[index(t[0],chr)][(Integer.parseInt(t[1])-shift_mut)/10000].add(Integer.parseInt(t[1]));
						}
					}
					input.close();
				}
				else{
					java.io.InputStream in=ZipOverlay.fileInputStream(file_exclude_regions_non_liver);
					BufferedReader input= new BufferedReader(new InputStreamReader(ZipFilter.filterInputStream(in)));
					String s="";
					while((s=input.readLine())!=null){
						String[] t=s.split("	");
						if(Integer.parseInt(t[1])>=shift_mut){
							exclude[index(t[0],chr)][(Integer.parseInt(t[1])-shift_mut)/10000].add(Integer.parseInt(t[1]));
						}
					}
					input.close();
				}
				
			}
			
				
			Comparator<Mutation> comp_mut=(Mutation m1, Mutation m2)->{
				return new Integer(m1.pos).compareTo(m2.pos);
			};
			
			SubthreadKataegisSingle[] threads_kataegis=new SubthreadKataegisSingle[chr.length];
			for (int chr_index=0;chr_index<chr.length;chr_index++){
				threads_kataegis[chr_index]=new SubthreadKataegisSingle();
				threads_kataegis[chr_index].chr_index=chr_index;
				threads_kataegis[chr_index].positions=positions;
				threads_kataegis[chr_index].start();
			}
			
			all_done=false;
			while(!all_done){
				all_done=true;
				for (int i=0;i<threads_kataegis.length;i++){
					if(threads_kataegis[i].status!=2){
						all_done=false;
					}
				}
				try{
				Thread.sleep(250);
				}
				catch(java.lang.InterruptedException e){
				}
			}
			System.out.println("A");
			
		
			for (int j=0;j<chr.length;j++){
				mutations[j]=new ArrayList[1+(chr_length[j]-shift_mut)/10000];
				
				for (int k=0;k<mutations[j].length;k++){
					mutations[j][k]=new ArrayList<Mutation>();
					
				}
			}
		
			for (int j=0;j<positions.length;j++){
				
				for (int k=0;k<positions[j].length;k++){
					for (int l=0;l<positions[j][k].size();l++){
						if(positions[j][k].get(l).pos>=shift_mut){
							mutations[k][(positions[j][k].get(l).pos-shift_mut)/10000].add(positions[j][k].get(l));
							
						}
					}
				}
			}
			System.out.println("A");
			
			
			SubthreadAnnotateAlignSingle[] threads_align=new SubthreadAnnotateAlignSingle[chr.length]; 
			for (int chr_index=0;chr_index<chr.length;chr_index++){
				threads_align[chr_index]=new SubthreadAnnotateAlignSingle();
				threads_align[chr_index].chr_index=chr_index;
				threads_align[chr_index].start();
			}
			all_done=false;
			while(!all_done){
				all_done=true;
				for (int i=0;i<threads_align.length;i++){
					if(threads_align[i].status!=2){
						all_done=false;
					}
				}
				try{
				Thread.sleep(250);
				}
				catch(java.lang.InterruptedException e){
				}
			}
			System.out.println("A");
			
			System.out.println("Start msi")	;
			Subthread_MSI[] threads_msi=new Subthread_MSI[chr.length];
			for (int chr_index=0;chr_index<chr.length;chr_index++){
				threads_msi[chr_index]=new Subthread_MSI();
				threads_msi[chr_index].chr_index=chr_index;
				threads_msi[chr_index].mutations=mutations;
				threads_msi[chr_index].start();
			}
			System.out.println("run msi")	;
			
			all_done=false;
			while(!all_done){
				all_done=true;
				for (int i=0;i<threads_msi.length;i++){
					if(threads_msi[i].status!=2){
						all_done=false;
					}
				}
				try{
				Thread.sleep(250);
				}
				catch(java.lang.InterruptedException e){
				}
			}
			System.out.println("A");
			System.out.println("msi done")	;
			
			remove_bad_msi_samples();
			System.out.println("remove msi done")	;
			
			
			for (int i=0;i<mutations.length;i++){
				for (int j=0;j<mutations[i].length;j++){
					for (int k=mutations[i][j].size()-1;k>=0;k--){
						if(mutations[i][j].get(k).exclude){
							mutations[i][j].remove(k);
						}
					}
				}
			}
			
		}
		//return pos_snv;
	}
	
	//read mutations of multiple cancer types and exclude low-quality mutations and problematic regions
	public static void read_mutations_entitites (String[] entity) throws java.io.IOException { 
		{
			
			ArrayList<String>[] donors=new ArrayList[entity.length];
			ArrayList<Mutation>[][][] positions=new ArrayList[entity.length][][];
					
			for (int a=0;a<entity.length;a++){
				donors[a]=new ArrayList<String>();
				
				for (int b=0;b<files_donors[a].length;b++){
					FileInputStream in=new FileInputStream(files_donors[a][b]);
					BufferedReader input= new BufferedReader(new InputStreamReader(ZipFilter.filterInputStream(in)));
					//input.readLine();
					String s="";
					while((s=input.readLine())!=null){
						donors[a].add(s);	
					}
					input.close();
				}
				
				
				
				positions[a]=new ArrayList[donors[a].size()][chr.length];
				
				for (int i=0;i<positions[a].length;i++){
					for (int j=0;j<chr.length;j++){
						positions[a][i][j]=new ArrayList<Mutation>();
					}
				}
				System.out.println(entity[a]);
				SubthreadRead[] threads_read=new SubthreadRead[chr.length];
				for (int chr_index=0;chr_index<chr.length;chr_index++){	
					//System.out.println(entity[a]+"	"+chr[chr_index]);
					threads_read[chr_index]=new SubthreadRead();
					threads_read[chr_index].chr_index=chr_index;
					threads_read[chr_index].a=a;
					threads_read[chr_index].positions=positions;
					threads_read[chr_index].donors=donors;
					threads_read[chr_index].file_mut_snv=files_mut_snv[a][chr_index];
					threads_read[chr_index].file_mut_indel=files_mut_indel[a][chr_index];
					threads_read[chr_index].start();
				}
				
				boolean all_done=false;
				while(!all_done){
					all_done=true;
					for (int i=0;i<threads_read.length;i++){
						if(threads_read[i].status!=2){
							all_done=false;
						}
					}
					try{
					Thread.sleep(250);
					}
					catch(java.lang.InterruptedException e){
					}
				}
				
			}
			System.out.println("XXXX");
			
			{
				exclude=new ArrayList[chr.length][];
				for (int i=0;i<chr.length;i++){
					exclude[i]=new ArrayList[1+(chr_length[i]-shift_mut)/10000];
					for (int j=0;j<exclude[i].length;j++){
						exclude[i][j]=new ArrayList<Integer>();
					}
				}
				
				java.io.InputStream in=ZipOverlay.fileInputStream(file_exclude_regions_non_liver);
				BufferedReader input= new BufferedReader(new InputStreamReader(ZipFilter.filterInputStream(in)));
				String s="";
				while((s=input.readLine())!=null){
					String[] t=s.split("	");
					if(Integer.parseInt(t[1])>=shift_mut){
						exclude[index(t[0],chr)][(Integer.parseInt(t[1])-shift_mut)/10000].add(Integer.parseInt(t[1]));
					}
				}
				input.close();
			}
			System.out.println("XXXX2");
			
			for (int a=0;a<entity.length;a++){
				System.out.println(entity[a]);
				SubthreadKataegis[] threads_kataegis=new SubthreadKataegis[chr.length];
				for (int chr_index=0;chr_index<chr.length;chr_index++){
					threads_kataegis[chr_index]=new SubthreadKataegis();
					threads_kataegis[chr_index].chr_index=chr_index;
					threads_kataegis[chr_index].a=a;
					threads_kataegis[chr_index].positions=positions;
					threads_kataegis[chr_index].start();
				}
				
				boolean all_done=false;
				while(!all_done){
					all_done=true;
					for (int i=0;i<threads_kataegis.length;i++){
						if(threads_kataegis[i].status!=2){
							all_done=false;
						}
					}
					try{
					Thread.sleep(250);
					}
					catch(java.lang.InterruptedException e){
					}
				}
			}
			System.out.println("XXXX3");
			{
				SubthreadAnnotateCoding[] threads_coding=new SubthreadAnnotateCoding[chr.length];
				for (int chr_index=0;chr_index<chr.length;chr_index++){	
					threads_coding[chr_index]=new SubthreadAnnotateCoding();
					threads_coding[chr_index].chr_index=chr_index;
					threads_coding[chr_index].positions=positions;
					threads_coding[chr_index].start();
				}
				boolean all_done=false;
				while(!all_done){
					all_done=true;
					for (int i=0;i<threads_coding.length;i++){
						if(threads_coding[i].status!=2){
							all_done=false;
						}
					}
					try{
					Thread.sleep(250);
					}
					catch(java.lang.InterruptedException e){
					}
				}
			}
			System.out.println("Coding Annotation done");
			
		
			ArrayList<Mutation>[][][] mutations_entities=new ArrayList[entity.length][chr.length][];
			{
				SubthreadRestructure[] threads_restructure=new SubthreadRestructure[entity.length];
				for (int a=0;a<entity.length;a++){
					threads_restructure[a]=new SubthreadRestructure();
					threads_restructure[a].mutations_entities=mutations_entities;
					threads_restructure[a].positions=positions;
					threads_restructure[a].a=a;
					threads_restructure[a].start();
				}
				boolean all_done=false;
				while(!all_done){
					all_done=true;
					for (int i=0;i<threads_restructure.length;i++){
						if(threads_restructure[i].status!=2){
							all_done=false;
						}
					}
					try{
					Thread.sleep(250);
					}
					catch(java.lang.InterruptedException e){
					}
				}
			}
			
			
			System.out.println("Restructure done");
			{
				
				SubthreadAnnotateAlign[] threads_align=new SubthreadAnnotateAlign[chr.length];
				for (int chr_index=0;chr_index<chr.length;chr_index++){
					threads_align[chr_index]=new SubthreadAnnotateAlign();
					threads_align[chr_index].chr_index=chr_index;
					threads_align[chr_index].mutations_entities=mutations_entities;
					threads_align[chr_index].start();
				}
				boolean all_done=false;
				while(!all_done){
					all_done=true;
					for (int i=0;i<threads_align.length;i++){
						if(threads_align[i].status!=2){
							all_done=false;
						}
					}
					try{
					Thread.sleep(250);
					}
					catch(java.lang.InterruptedException e){
					}
				}
				
				
			}
			
			System.out.println("Align annotation done");
			
			
			Subthread_MSI_Multiple[] threads_msi=new Subthread_MSI_Multiple[chr.length];
			for (int i=0;i<threads_msi.length;i++){
				threads_msi[i]=new Subthread_MSI_Multiple();
				threads_msi[i].chr_index=i;
				threads_msi[i].mutations=mutations_entities;
				threads_msi[i].start();
			}
			
			boolean all_done=false;
			while(!all_done){
				all_done=true;
				for (int i=0;i<threads_msi.length;i++){
					if(threads_msi[i].status!=2){
						all_done=false;
					}
				}
				try{
				Thread.sleep(250);
				}
				catch(java.lang.InterruptedException e){
				}
			}
			
			
			for (int l=0;l<entity.length;l++){
				
				ArrayList<String> donors_entity=new ArrayList<String>();
				Hashtable<String,Integer> table_entity=new Hashtable<String,Integer>();
				ArrayList<int[]> counts_bad=new ArrayList<int[]>();
				ArrayList<int[]> counts_msi=new ArrayList<int[]>();
				
				for (int i=0;i<mutations_entities[l].length;i++){
					for (int j=0;j<mutations_entities[l][i].length;j++){
						if(low(chr[i])<=coverage[i][j]&&coverage[i][j]<high(chr[i])){
							for (int k=0;k<mutations_entities[l][i][j].size();k++){
								Integer ii=table_entity.get(mutations_entities[l][i][j].get(k).donor);
								if(ii==null){
									ii=donors_entity.size();
									table_entity.put(mutations_entities[l][i][j].get(k).donor, ii);
									donors_entity.add(mutations_entities[l][i][j].get(k).donor);
									counts_bad.add(new int[]{0,0});
									counts_msi.add(new int[]{0,0});
								}
								counts_bad.get(ii)[0]++;
								if(mutations_entities[l][i][j].get(k).group>=1){//>=2
									counts_bad.get(ii)[1]++;
								}
								
								counts_msi.get(ii)[0]++;
								if(mutations_entities[l][i][j].get(k).msi){
									counts_msi.get(ii)[1]++;
								}

							}
						}
					}
				}
				
				
				Hashtable<String,Integer> table_bad_donor_entity=new Hashtable<String,Integer>();
				ArrayList<String> bad_donors_entity=new ArrayList<String>();
				Hashtable<String,Integer> table_msi_donors=new Hashtable<String,Integer>();
				ArrayList<String> msi_donors=new ArrayList<String>();
				for (int i=0;i<donors_entity.size();i++){
					if((double)(counts_bad.get(i)[1])/(double)(counts_bad.get(i)[0])>0.25){
						table_bad_donor_entity.put(donors_entity.get(i),bad_donors_entity.size());
						bad_donors_entity.add(donors_entity.get(i));
					}
					if((double)(counts_msi.get(i)[1])/(double)(counts_msi.get(i)[0])>0.2){
						table_msi_donors.put(donors_entity.get(i),msi_donors.size());
						msi_donors.add(donors_entity.get(i));
					}
				}
				
				for (int i=0;i<mutations_entities[l].length;i++){
					for (int j=0;j<mutations_entities[l][i].length;j++){
						for (int k=mutations_entities[l][i][j].size()-1;k>=0;k--){
							if(table_bad_donor_entity.get(mutations_entities[l][i][j].get(k).donor)!=null||table_msi_donors.get(mutations_entities[l][i][j].get(k).donor)!=null||mutations_entities[l][i][j].get(k).msi||mutations_entities[l][i][j].get(k).msi2){
								mutations_entities[l][i][j].remove(k);
							}
						}
					}
				}
				
				
			}
			
			for (int a=0;a<mutations_entities.length;a++){
				for (int i=0;i<mutations_entities[a].length;i++){
					for (int j=0;j<mutations_entities[a][i].length;j++){
						for (int k=mutations_entities[a][i][j].size()-1;k>=0;k--){
							if(mutations_entities[a][i][j].get(k).exclude){
								mutations_entities[a][i][j].remove(k);
							}
						}
					}
				}
			}
			
			int[][][][] n_indel_quality2=new int[entity.length][chr.length][][];
			int[][][][] n_quality2=new int[entity.length][chr.length][][];
			
			for (int i=0;i<entity.length;i++){
				for (int j=0;j<chr.length;j++){
					n_indel_quality2[i][j]=new int[1+(chr_length[j]-shift_mut)/10000][10];
					n_quality2[i][j]=new int[1+(chr_length[j]-shift_mut)/10000][10];
				}
			}
			
			
			for (int i=0;i<mutations_entities.length;i++){
				for (int j=0;j<mutations_entities[0].length;j++){
					for (int k=0;k<mutations_entities[0][j].length;k++){
					
						for(int l=0;l<mutations_entities[i][j][k].size();l++){
							boolean snv=false;
							if(mutations_entities[i][j][k].get(l).ref.length()==1&&mutations_entities[i][j][k].get(l).alt.length()==1){
								snv=true;
							}
							boolean good_quality=false;
							if(mutations_entities[i][j][k].get(l).group==0){//||mutations_entities[i][j][k].get(l).group==1
								good_quality=true;
							}
							
							
							if(snv){

							}
							else{

								if(good_quality){
									n_indel_quality2[i][j][k][(mutations_entities[i][j][k].get(l).pos-k*10000-shift_mut)/1000]++;	
								}
								
							}

							if(good_quality){
								n_quality2[i][j][k][(mutations_entities[i][j][k].get(l).pos-k*10000-shift_mut)/1000]++;	
							}
						}
						
						
					}
					
				}
			}
			
			output(file_n_indel_quality2,n_indel_quality2,entity);
			output(file_n_quality2,n_quality2,entity);
		}
	}
	
	//write the mutation counts of multiple cancer types
	public static void output(String file_out, int[][][][] n,String[] entities) throws java.io.IOException {
		{
			java.io.FileOutputStream out=new java.io.FileOutputStream(file_out);//+".txt"
			BufferedWriter output= new BufferedWriter(new java.io.OutputStreamWriter(ZipFilter.filterOutputStream(out, file_out)));
			output.write("Chr	Pos");
			for (int j=0;j<entities.length;j++){
				output.write("	"+entities[j]);
			}
			output.newLine();
			for (int i=0;i<chr.length;i++){
				for (int j=0;j<(chr_length[i]-shift_mut)/10000;j++){
					for (int l=0;l<10;l++){
						output.write(chr[i]+"	"+(j*10000+l*1000+shift_mut));
						for (int k=0;k<n.length;k++){
							output.write("	"+n[k][i][j][l]);
						}
						output.newLine();
					}
				}
			}
			output.close();
			
		}
	}
	
	public static int index(String s, String[] t){
		for (int i=0;i<t.length;i++){
			if(t[i].equals(s)){
				return i;
			}
		}
		return -1;
	}
	
	
	public static int index(String s, String[] t1, String[] t2){
		for (int i=0;i<t1.length;i++){
			if(t1[i].equals(s)){
				return i;
			}
		}
		for (int i=0;i<t2.length;i++){
			if(t2[i].equals(s)){
				return i;
			}
		}
		return -1;
	}
	
	
	public static int index (String s, ArrayList<String> t){
		for (int i=0;i<t.size();i++){
			if(t.get(i).equals(s)){
				return i;
			}
		}
		return -1;
	}
	
	//lower coverage threshold based on gnomAD
	public static double low(String chr){
		if(chr.equals("X")){
			return 0.11;
		}
		else if(chr.equals("19")){
			return 0.35;
		}
		else{
			return 0.4;
		}
	}
	
	//upper coverage threshold based on gnomAD
	public static double high(String chr){
		if(chr.equals("X")){
			return 0.25;
		}
		else if(chr.equals("19")){
			return 0.62;
		}
		else{
			return 0.62;
		}
	}
	
	//Subthread to annotate 36mer based alignment scores for mutations of a single cancer type
	private static class SubthreadAnnotateAlignSingle extends ThreadEx{
		int chr_index=-1;
		int status=0;
		public void runEx() throws java.io.IOException {
			status=1;
			{
				interval_align[chr_index]=new ArrayList[1+(chr_length[chr_index]-shift_mut)/10000];
				alignability[chr_index]=new double[1+(chr_length[chr_index]-shift_mut)/10000];
				alignability_fine[chr_index]=new double[1+(chr_length[chr_index]-shift_mut)/1000];
				for (int k=0;k<interval_align[chr_index].length;k++){
					interval_align[chr_index][k]=new ArrayList<int[]>();
				}
				
				for (int j=0;j<1+(chr_length[chr_index]-shift_mut)/1000000;j++){
					java.io.InputStream in=ZipOverlay.fileInputStream(file_dichotomous+chr[chr_index]+"_"+j+".txt");
					BufferedReader input= new BufferedReader(new InputStreamReader(ZipFilter.filterInputStream(in)));
					String s="";
					while((s=input.readLine())!=null){
						String[] t=s.split("	");
						
						for (int kk=(Integer.parseInt(t[0])+18-shift_mut)/10000;kk<=(Integer.parseInt(t[1])+18-shift_mut)/10000;kk++){
							if(kk>=0){
								for (int l=0;l<mutations[chr_index][kk].size();l++){
									if(Integer.parseInt(t[0])+18<=mutations[chr_index][kk].get(l).pos&&mutations[chr_index][kk].get(l).pos<=Integer.parseInt(t[1])+18){
										mutations[chr_index][kk].get(l).group=Integer.parseInt(t[2]);
									}
								}
								
								int overlap=Math.min((kk+1)*10000+shift_mut,Integer.parseInt(t[1])+18)-Math.max(kk*10000+shift_mut,Integer.parseInt(t[0])+18);
								if(overlap>0){
									if(Integer.parseInt(t[2])==0){//||Integer.parseInt(t[2])==1
										interval_align[chr_index][kk].add(new int[]{Math.max(kk*10000+shift_mut,Integer.parseInt(t[0])+18),Math.min((kk+1)*10000+shift_mut,Integer.parseInt(t[1])+18)});
								//		alignability[chr_index][kk]+=(double)(Math.min((kk+1)*10000,Integer.parseInt(t[1])+shift)-Math.max(kk*10000,Integer.parseInt(t[0])+shift))/10000.0;
									}
								}
							}
							
							
							
						}
						
					}
					input.close();
				}
				
				for (int j=0;j<mutations[chr_index].length;j++){
					for (int k=0;k<exclude[chr_index][j].size();k++){
						for (int l=0;l<mutations[chr_index][j].size();l++){
							if(exclude[chr_index][j].get(k)<=mutations[chr_index][j].get(l).pos&&mutations[chr_index][j].get(l).pos<=exclude[chr_index][j].get(k)+100){
								mutations[chr_index][j].get(l).exclude=true;
							}
						}
					}
				}
				
				
				ArrayList<int[]>[] exclude_comp=new ArrayList[1+(chr_length[chr_index]-shift_mut)/10000];
				for (int i=0;i<exclude_comp.length;i++){
					exclude_comp[i]=new ArrayList<int[]>();
				}
				
				for (int k=0;k<exclude[chr_index].length;k++){
					if(exclude[chr_index][k].size()==0){
						exclude_comp[k].add(new int[]{k*10000+shift_mut,(k+1)*10000+shift_mut});
					}
					else{
						Collections.sort(exclude[chr_index][k]);
						for (int l=-1;l<exclude[chr_index][k].size();l++){
							if(l==-1){
								exclude_comp[k].add(new int[]{k*10000+shift_mut,exclude[chr_index][k].get(0)});
							}
							else if(l<exclude[chr_index][k].size()-1){
								if(exclude[chr_index][k].get(l+1)>exclude[chr_index][k].get(l)+100){
									exclude_comp[k].add(new int[]{exclude[chr_index][k].get(l)+100,exclude[chr_index][k].get(l+1)});
								}
							}
							else  if(l==exclude[chr_index][k].size()-1){
								exclude_comp[k].add(new int[]{exclude[chr_index][k].get(l)+100,(k+1)*10000+shift_mut});
							}
						}
					}
				}
				
				Comparator<int[]> comp_int=(int[] x, int[] y)->{
					return new Integer(x[0]).compareTo(y[0]);
				};
				
				for (int k=0;k<interval_align[chr_index].length;k++){
					ArrayList<int[]> new_align=new ArrayList<int[]>();
					for (int l=0;l<interval_align[chr_index][k].size();l++){
						for (int m=0;m<exclude_comp[k].size();m++){
							int[] a={Math.max(exclude_comp[k].get(m)[0],interval_align[chr_index][k].get(l)[0]),Math.min(exclude_comp[k].get(m)[1],interval_align[chr_index][k].get(l)[1])};
							if(a[1]>a[0]){
								new_align.add(a);
							}
						}
					}
					Collections.sort(new_align,comp_int);
					
					interval_align[chr_index][k]=new_align;
					
				}
				
				
				for (int k=0;k<interval_align[chr_index].length;k++){
					for (int l=0;l<interval_align[chr_index][k].size();l++){
						alignability[chr_index][k]+=(double)(interval_align[chr_index][k].get(l)[1]-interval_align[chr_index][k].get(l)[0])/10000.0;
					}
				}
				
				for (int k=0;k<interval_align[chr_index].length;k++){
					for (int l=0;l<interval_align[chr_index][k].size();l++){
						for (int m=(interval_align[chr_index][k].get(l)[0]-shift_mut)/1000;m<=(interval_align[chr_index][k].get(l)[1]-shift_mut)/1000;m++){
							int a=Math.min((m+1)*1000+shift_mut, interval_align[chr_index][k].get(l)[1])-Math.max(m*1000+shift_mut, interval_align[chr_index][k].get(l)[0]);
							if(a>0){
								alignability_fine[chr_index][m]+=(double)(a)/1000.0;
							}
						}
					}
				}
				
			}
			status=2;
		}
		
	}
	
	//Subthread to annotate 36mer based alignment scores for mutations of multiple cancer types
	private static class SubthreadAnnotateAlign extends ThreadEx{
		
		int chr_index=-1;
		ArrayList<Mutation>[][][] mutations_entities=null;
		int status=0;
		
		public void runEx() throws java.io.IOException {
			status=1;
			{
				for (int j=0;j<1+(chr_length[chr_index]-shift_mut)/1000000;j++){
					java.io.InputStream in=ZipOverlay.fileInputStream(file_dichotomous+chr[chr_index]+"_"+j+".txt");
					BufferedReader input= new BufferedReader(new InputStreamReader(ZipFilter.filterInputStream(in)));
					String s="";
					while((s=input.readLine())!=null){
						String[] t=s.split("	");
						
						for (int kk=(Integer.parseInt(t[0])+18-shift_mut)/10000;kk<=(Integer.parseInt(t[1])+18-shift_mut)/10000;kk++){
							if(kk>=0){
								for (int a=0;a<mutations_entities.length;a++){
									for (int l=0;l<mutations_entities[a][chr_index][kk].size();l++){
										if(Integer.parseInt(t[0])+18<=mutations_entities[a][chr_index][kk].get(l).pos&&mutations_entities[a][chr_index][kk].get(l).pos<=Integer.parseInt(t[1])+18){
											mutations_entities[a][chr_index][kk].get(l).group=Integer.parseInt(t[2]);
										}
									}
								}
							}
							
						}
					}
					input.close();
				}
				
				for (int a=0;a<mutations_entities.length;a++){
					for (int j=0;j<mutations_entities[a][chr_index].length;j++){
						for (int k=0;k<exclude[chr_index][j].size();k++){
							for (int l=0;l<mutations_entities[a][chr_index][j].size();l++){
								if(exclude[chr_index][j].get(k)<=mutations_entities[a][chr_index][j].get(l).pos&&mutations_entities[a][chr_index][j].get(l).pos<=exclude[chr_index][j].get(k)+100){
									mutations_entities[a][chr_index][j].get(l).exclude=true;
								}
							}
						}
					}
				}
				
				
				
			}
			status=2;
		}
	}
	
	//Subthread to restructure mutations from samples to intervals of the genome
	private static class SubthreadRestructure extends Thread{
		ArrayList<Mutation>[][][] mutations_entities=null;
		ArrayList<Mutation>[][][] positions=null;
		int a=-1;
		int status=0;
		public void run(){ 
			status=1;
			for (int j=0;j<chr.length;j++){
				mutations_entities[a][j]=new ArrayList[1+(chr_length[j]-shift_mut)/10000];
				for (int k=0;k<mutations_entities[a][j].length;k++){
					mutations_entities[a][j][k]=new ArrayList<Mutation>();
				}
			}
		
			for (int j=0;j<positions[a].length;j++){
				for (int k=0;k<positions[a][j].length;k++){//chr
					for (int l=0;l<positions[a][j][k].size();l++){
						if(positions[a][j][k].get(l).pos>=shift_mut){
							mutations_entities[a][k][(positions[a][j][k].get(l).pos-shift_mut)/10000].add(positions[a][j][k].get(l));
							
						}
						
					}
				}
			}
			status=2;
		}
	}
	
	//Subthread to annotate which mutations are coding
	private static class SubthreadAnnotateCoding extends ThreadEx{
		int chr_index=-1;
		ArrayList<Mutation>[][][] positions=null;
		int status=0;
		public void runEx() throws java.io.IOException {
			status=1;
			{
				Hashtable<Integer,Integer> table_code=new Hashtable<Integer,Integer>();
				java.io.InputStream in=ZipOverlay.fileInputStream(file_as_annotation+chr[chr_index]+".txt");
				BufferedReader input= new BufferedReader(new InputStreamReader(ZipFilter.filterInputStream(in)));
				input.readLine();
				String s="";
				while((s=input.readLine())!=null){
					String[] t=s.split("	");
					if(t.length==7){
						int syn=0;
						if(t[4].equals(t[2])){
							syn++;
						}
						if(t[5].equals(t[2])){
							syn++;
						}
						if(t[6].equals(t[2])){
							syn++;
						}
						table_code.put(Integer.parseInt(t[0]),syn);
					}
				}
				input.close();
				
				for (int a=0;a<positions.length;a++){
					for (int i=0;i<positions[a].length;i++){
						for (int j=0;j<positions[a][i][chr_index].size();j++){
							positions[a][i][chr_index].get(j).coding=table_code.get(positions[a][i][chr_index].get(j).pos)!=null;
						}
					}
				}
			}
			status=2;
		}
	}
	
	//Subthread to read mutations of a signle cancer type
	private static class SubthreadReadSingle extends ThreadEx{
		int chr_index=-1;
		ArrayList<Mutation>[][] positions=null;
		ArrayList<String> donors=null;
		String[] file_mut_snv=null;
		String[] file_mut_indel=null;
		int status=0;
		public void runEx() throws java.io.IOException {
			status=1;
			{
				for (int b=0;b<file_mut_snv.length;b++){
					FileInputStream in=new FileInputStream(file_mut_snv[b]);
					BufferedReader input= new BufferedReader(new InputStreamReader(ZipFilter.filterInputStream(in)));
					String s="";
					while((s=input.readLine())!=null){
						String[] t=s.split("	");
						if(index(t[0],donors)!=-1){
							positions[index(t[0],donors)][chr_index].add(new Mutation(Integer.parseInt(t[1]),t[2],t[3],t[0]));
						}
					}
					input.close();
				}
				
				for (int b=0;b<file_mut_indel.length;b++){
					FileInputStream in=new FileInputStream(file_mut_indel[b]);
					BufferedReader input= new BufferedReader(new InputStreamReader(ZipFilter.filterInputStream(in)));
					String s="";
					while((s=input.readLine())!=null){
						String[] t=s.split("	");
						if(index(t[0],donors)!=-1){
							String x="";
							if(t.length>3){
								x=t[3];
							}
							else{
								x="";
							}
							positions[index(t[0],donors)][chr_index].add(new Mutation(Integer.parseInt(t[1]),t[2],x,t[0]));			
						}
					}
					input.close();
				}
				
				
			
				ArrayList<int[]> intervals_coding_raw=new ArrayList<int[]>();
				int prev=-1;
				int start=-1;
				Hashtable<Integer,Integer> table_coding=new Hashtable<Integer,Integer>();
				java.io.InputStream in=ZipOverlay.fileInputStream(file_as_annotation+chr[chr_index]+".txt");
				BufferedReader input= new BufferedReader(new InputStreamReader(ZipFilter.filterInputStream(in)));
				input.readLine();
				String s="";
				while((s=input.readLine())!=null){
					String[] t=s.split("	");
					if(t.length==7){
						int syn=0;
						if(t[4].equals(t[2])){
							syn++;
						}
						if(t[5].equals(t[2])){
							syn++;
						}
						if(t[6].equals(t[2])){
							syn++;
						}
						table_coding.put(Integer.parseInt(t[0]),syn);
						
						if(Integer.parseInt(t[0])-prev>1){
							if(start!=-1){
								intervals_coding_raw.add(new int[]{start,prev});
							}
							start=Integer.parseInt(t[0]);
						}
						prev=Integer.parseInt(t[0]);
					}
				}
				input.close();
				
				for (int i=0;i<donors.size();i++){
					for (int j=0;j<positions[i][chr_index].size();j++){
						positions[i][chr_index].get(j).coding=table_coding.get(positions[i][chr_index].get(j).pos)!=null;
					}
				}
				
			}
			status=2;
		}
		
	}
	
	//Subthread to read mutations of multiple cancer types
	private static class SubthreadRead extends ThreadEx{
		int chr_index=-1;
		int a=-1;
		ArrayList<Mutation>[][][] positions=null;
		ArrayList<String>[] donors=null;
		String[] file_mut_snv=null;
		String[] file_mut_indel=null;
		int status=0;
		public void runEx() throws java.io.IOException {
			status=1;
			{
				for (int b=0;b<file_mut_snv.length;b++){
					FileInputStream in=new FileInputStream(file_mut_snv[b]);
					BufferedReader input= new BufferedReader(new InputStreamReader(ZipFilter.filterInputStream(in)));
					String s="";
					while((s=input.readLine())!=null){
						String[] t=s.split("	");
						if(index(t[0],donors[a])!=-1){
							positions[a][index(t[0],donors[a])][chr_index].add(new Mutation(Integer.parseInt(t[1]),t[2],t[3],t[0]));
						}
					}
					input.close();
				}
				for (int b=0;b<file_mut_indel.length;b++){
					FileInputStream in=new FileInputStream(file_mut_indel[b]);
					BufferedReader input= new BufferedReader(new InputStreamReader(ZipFilter.filterInputStream(in)));
					String s="";
					while((s=input.readLine())!=null){
						String[] t=s.split("	");
						if(index(t[0],donors[a])!=-1){
							String x="";
							if(t.length>3){
								x=t[3];
							}
							else{
								x="";
							}
							positions[a][index(t[0],donors[a])][chr_index].add(new Mutation(Integer.parseInt(t[1]),t[2],x,t[0]));			
						}
					}
					input.close();
				}
			}
			status=2;
		}
		
	}
	
	//Subthread to filter out mutations that come from the same sample and exhibit local clustering (kataegis events).
	//Filtering these events out is important so that they do not get confused with mutational hotspots.
	private static class SubthreadKataegisSingle extends Thread{
		ArrayList<Mutation>[][] positions=null;
		int chr_index=-1;
		int status=0;
		
		public void run(){
			status=1;
			Comparator<Mutation> comp_mut=(Mutation m1, Mutation m2)->{
				return new Integer(m1.pos).compareTo(m2.pos);
			};
			{
				ArrayList<Integer>[] index_kat=new ArrayList[positions.length];
				for (int i=0;i<positions.length;i++){
					index_kat[i]=new ArrayList<Integer>();
					Collections.sort(positions[i][chr_index],comp_mut);
					for (int j=0;j<positions[i][chr_index].size()-7;j++){
						double avg=0;
						int k=0;
						for (;k<6;k++){
							avg+=positions[i][chr_index].get(k+j+1).pos-positions[i][chr_index].get(k+j).pos;
						}
						if(avg/(double)(k+1)<=1000){
							while(k+j+1<positions[i][chr_index].size()&&k<100&&avg/(double)(k+1)<=1000){
								avg+=positions[i][chr_index].get(k+j+1).pos-positions[i][chr_index].get(k+j).pos;
								k++;
							}
							for (int l=0;l<k;l++){
								index_kat[i].add(j+l);
							}
							j+=k;
						}
					}
				}
				for (int i=0;i<index_kat.length;i++){
					for (int j=index_kat[i].size()-1;j>=0;j--){
						positions[i][chr_index].remove(index_kat[i].get(j).intValue());
					}
				}
		
			}
			status=2;
		}
		
	}
	
	//Subthread to filter out mutations that come from the same sample and exhibit local clustering (kataegis events) for multiple cancer types.
	//Filtering these events out is important so that they do not get confused with mutational hotspots.
	private static class SubthreadKataegis extends Thread{
		int a=-1;
		ArrayList<Mutation>[][][] positions=null;
		int chr_index=-1;
		int status=0;
		
		
		public void run(){
			status=1;
			{
				
				Comparator<Mutation> comp_mut=(Mutation m1, Mutation m2)->{
					return new Integer(m1.pos).compareTo(m2.pos);
				};
				ArrayList<Integer>[] index_kat=new ArrayList[positions[a].length];
				for (int i=0;i<positions[a].length;i++){
					index_kat[i]=new ArrayList<Integer>();
					Collections.sort(positions[a][i][chr_index],comp_mut);
					for (int j=0;j<positions[a][i][chr_index].size()-7;j++){
						double avg=0;
						int k=0;
						for (;k<6;k++){
							avg+=positions[a][i][chr_index].get(k+j+1).pos-positions[a][i][chr_index].get(k+j).pos;
						}
						if(avg/(double)(k+1)<=1000){
							while(k+j+1<positions[a][i][chr_index].size()&&k<100&&avg/(double)(k+1)<=1000){
								avg+=positions[a][i][chr_index].get(k+j+1).pos-positions[a][i][chr_index].get(k+j).pos;
								k++;
							}
							for (int l=0;l<k;l++){
								index_kat[i].add(j+l);
							}
							j+=k;
						}
					}
				}
				for (int i=0;i<index_kat.length;i++){
					for (int j=index_kat[i].size()-1;j>=0;j--){
						positions[a][i][chr_index].remove(index_kat[i].get(j).intValue());
					}
				}
			}
			status=2;
		}
		
	}
		
	//Subthread to annotate which mutations are in splice sites
	private static class SubthreadSplice extends ThreadEx{
		int i=-1;
		double[][] coverage=null;
		ArrayList<Mutation>[][] mutations=null;
		int[][] splice=null;
		int[] splice_total=null;
		int status=0;
		public void runEx() throws java.io.IOException {
			status=1;
			splice=new int[1+(chr_length[i]-shift_mut)/10000][2];
			splice_total=new int[1+(chr_length[i]-shift_mut)/10000];
			{
				for (int j=0;j<chr_length[i]/1000000;j++){
					Hashtable<String,double[]> table=new Hashtable<String,double[]>();
					if(ZipOverlay.exists(new File(file_splice_ai+chr[i]+"_"+(j+1)+".txt"))){
						java.io.InputStream in=ZipOverlay.fileInputStream(file_splice_ai+chr[i]+"_"+(j+1)+".txt");
						BufferedReader input= new BufferedReader(new InputStreamReader(ZipFilter.filterInputStream(in)));
						String s="";
						while((s=input.readLine())!=null){
							String[] t=s.split("	");
							table.put(t[0]+"_"+t[1],new double[]{Double.parseDouble(t[2]),Double.parseDouble(t[3]),Double.parseDouble(t[4]),Double.parseDouble(t[5])});
						}
						input.close();
					}
					
					
					for (int k=(j*1000000-shift_mut)/10000;k<((j+1)*1000000-shift_mut)/10000;k++){
						if(k>=0){
							if(low(chr[i])<=coverage[i][k]&&coverage[i][k]<high(chr[i])){
								for (int l=0;l<mutations[i][k].size();l++){
									if(!mutations[i][k].get(l).coding&&(mutations[i][k].get(l).group==0)&&mutations[i][k].get(l).ref.length()==1&&mutations[i][k].get(l).alt.length()==1){	//||mutations[i][k].get(l).group==1
										
										double[] dd=table.get(mutations[i][k].get(l).pos+"_"+mutations[i][k].get(l).alt);
										if(dd!=null){
											if(Math.max(dd[0], dd[2])>=0.5){
												splice[k][0]++;
											}
											if(Math.max(dd[1], dd[3])>=0.5){
												splice[k][1]++;
											}
										}
										splice_total[k]++;
									}	
										
										
								}
					
							 }
						}
						
					}
				}
			}
			status=2;
		}
	}
	
	//annotate mutation type
	public static int index(String ref, String alt){
		if(ref.equals("A")){
			if(alt.equals("T")){
				return 0;
			}
			else if(alt.equals("C")){
				return 1;
			}
			else if(alt.equals("G")){
				return 2;
			}
		}
		else if(ref.equals("C")){
			if(alt.equals("A")){
				return 0;
			}
			else if(alt.equals("G")){
				return 1;
			}
			else if(alt.equals("T")){
				return 2;
			}
		}
		else if(ref.equals("G")){
			if(alt.equals("T")){
				return 0;
			}
			else if(alt.equals("C")){
				return 1;
			}
			else if(alt.equals("A")){
				return 2;
			}
		}
		else if(ref.equals("T")){
			if(alt.equals("A")){
				return 0;
			}
			else if(alt.equals("G")){
				return 1;
			}
			else if(alt.equals("C")){
				return 2;
			}
		}	
		return -1;
	}
	
	//find reference nucleotide in a genomic position of Hg19
	public static char genome(int pos, ArrayList<char[]> genome){
		
		if(pos-1>=0&&(pos-1)/50<genome.size()){
			char[] s = genome.get((pos-1)/50);
			if((pos-1)%50<s.length)
				return s[(pos-1)%50];
		}
		return 'N';
	}
	
	//read reference genome for a chromosome
	public static ArrayList<char[]> read_genome(String c) throws java.io.IOException {
		ArrayList<char[]> genome=new ArrayList<char[]>();
		{
			java.io.InputStream in=ZipOverlay.fileInputStream(file_genome+c+".fa");//chr[i]
			BufferedReader input= new BufferedReader(new InputStreamReader(ZipFilter.filterInputStream(in)));
			input.readLine();
			String s="";
			while((s=input.readLine())!=null){
				genome.add(s.toUpperCase().toCharArray());
			}
			input.close();
		}
		
		return genome;
	}
	
	
}
